I"mp<h1 class="no_toc" id="querying-and-data-transformations">Querying and Data Transformations</h1>

<h2 class="no_toc text-delta" id="table-of-contents">Table of contents</h2>

<ol id="markdown-toc">
  <li><a href="#querying-with-flux" id="markdown-toc-querying-with-flux">Querying With Flux</a>    <ol>
      <li><a href="#from" id="markdown-toc-from">from()</a></li>
      <li><a href="#range" id="markdown-toc-range">range()</a>        <ol>
          <li><a href="#start-and-stop" id="markdown-toc-start-and-stop">start and stop</a></li>
          <li><a href="#now" id="markdown-toc-now">now()</a>            <ol>
              <li><a href="#calling-range-with-relative-durations" id="markdown-toc-calling-range-with-relative-durations">Calling range() with Relative Durations</a></li>
            </ol>
          </li>
          <li><a href="#defining-ranges-with-integers" id="markdown-toc-defining-ranges-with-integers">Defining Ranges with Integers</a></li>
          <li><a href="#defining-ranges-with-times" id="markdown-toc-defining-ranges-with-times">Defining Ranges with Times</a></li>
          <li><a href="#calculating-start-and-stop-times" id="markdown-toc-calculating-start-and-stop-times">Calculating Start and Stop Times</a></li>
          <li><a href="#start-and-stop-types-can-be-different" id="markdown-toc-start-and-stop-types-can-be-different">Start and Stop Types Can Be Different</a></li>
        </ol>
      </li>
      <li><a href="#filter" id="markdown-toc-filter">filter()</a>        <ol>
          <li><a href="#filter-basics" id="markdown-toc-filter-basics">Filter Basics</a></li>
          <li><a href="#anatomy-of-a-row" id="markdown-toc-anatomy-of-a-row">Anatomy of a Row</a></li>
          <li><a href="#filtering-measurements" id="markdown-toc-filtering-measurements">Filtering Measurements</a></li>
          <li><a href="#filtering-tags" id="markdown-toc-filtering-tags">Filtering Tags</a></li>
          <li><a href="#filtering-by-field" id="markdown-toc-filtering-by-field">Filtering by Field</a></li>
          <li><a href="#filter-by-exists" id="markdown-toc-filter-by-exists">Filter by Exists</a></li>
          <li><a href="#filtering-by-field-value" id="markdown-toc-filtering-by-field-value">Filtering by Field Value</a></li>
          <li><a href="#compound-filters" id="markdown-toc-compound-filters">Compound Filters</a></li>
          <li><a href="#regular-expressions" id="markdown-toc-regular-expressions">Regular Expressions</a>            <ol>
              <li><a href="#if-then-else" id="markdown-toc-if-then-else">If, Then, Else</a></li>
            </ol>
          </li>
          <li><a href="#types-in-comparisons" id="markdown-toc-types-in-comparisons">Types In Comparisons</a></li>
        </ol>
      </li>
      <li><a href="#queries-and-the-data-model" id="markdown-toc-queries-and-the-data-model">Queries and the Data Model</a></li>
    </ol>
  </li>
  <li><a href="#flux-data-transformations" id="markdown-toc-flux-data-transformations">Flux Data Transformations</a>    <ol>
      <li><a href="#grouping" id="markdown-toc-grouping">Grouping</a>        <ol>
          <li><a href="#group" id="markdown-toc-group">group()</a></li>
          <li><a href="#group-and-type-conflicts" id="markdown-toc-group-and-type-conflicts">group() and Type Conflicts</a></li>
          <li><a href="#dropkeep" id="markdown-toc-dropkeep">drop()/keep()</a></li>
          <li><a href="#rename" id="markdown-toc-rename">rename()</a></li>
          <li><a href="#creating-a-single-table-or-ungrouping" id="markdown-toc-creating-a-single-table-or-ungrouping">Creating a Single Table or Ungrouping</a></li>
        </ol>
      </li>
      <li><a href="#windowing" id="markdown-toc-windowing">Windowing</a></li>
      <li><a href="#windowing-and-aggregatewindow" id="markdown-toc-windowing-and-aggregatewindow">Windowing and aggregateWindow()</a></li>
      <li><a href="#real-world-data-example-of-grouping" id="markdown-toc-real-world-data-example-of-grouping">Real World Data Example of Grouping</a>        <ol>
          <li><a href="#default-grouping" id="markdown-toc-default-grouping">Default Grouping</a></li>
          <li><a href="#group-1" id="markdown-toc-group-1">group()</a></li>
          <li><a href="#dropkeep-1" id="markdown-toc-dropkeep-1">drop()/keep()</a></li>
          <li><a href="#grouping-and-type-conflicts" id="markdown-toc-grouping-and-type-conflicts">Grouping and Type Conflicts</a></li>
          <li><a href="#creating-a-single-table" id="markdown-toc-creating-a-single-table">Creating a Single Table</a></li>
        </ol>
      </li>
      <li><a href="#aggregations" id="markdown-toc-aggregations">Aggregations</a>        <ol>
          <li><a href="#mean" id="markdown-toc-mean">mean()</a></li>
          <li><a href="#min-and-max" id="markdown-toc-min-and-max">min() and max()</a></li>
          <li><a href="#count" id="markdown-toc-count">count()</a></li>
          <li><a href="#aggregates-and-selectors" id="markdown-toc-aggregates-and-selectors">Aggregates and Selectors</a></li>
        </ol>
      </li>
      <li><a href="#yielding" id="markdown-toc-yielding">Yielding</a>        <ol>
          <li><a href="#returning-multiple-aggregations-with-multiple-yield-functions" id="markdown-toc-returning-multiple-aggregations-with-multiple-yield-functions">Returning multiple aggregations with multiple yield() functions</a></li>
          <li><a href="#using-variables-to-perform-multiple-aggregations" id="markdown-toc-using-variables-to-perform-multiple-aggregations">Using variables to perform multiple aggregations</a></li>
        </ol>
      </li>
      <li><a href="#pivoting" id="markdown-toc-pivoting">Pivoting</a>        <ol>
          <li><a href="#the-fieldsascol-function" id="markdown-toc-the-fieldsascol-function">The fieldsAsCol() function</a></li>
        </ol>
      </li>
      <li><a href="#mapping" id="markdown-toc-mapping">Mapping</a>        <ol>
          <li><a href="#in-place-transformation" id="markdown-toc-in-place-transformation">In place transformation</a></li>
          <li><a href="#new-columns" id="markdown-toc-new-columns">New column(s)</a></li>
          <li><a href="#conditionally-transform-data" id="markdown-toc-conditionally-transform-data">Conditionally transform data</a></li>
          <li><a href="#changing-types" id="markdown-toc-changing-types">Changing types</a></li>
          <li><a href="#the-rowsmap-function" id="markdown-toc-the-rowsmap-function">The rows.map() function</a></li>
        </ol>
      </li>
      <li><a href="#returning-values-and-arrays" id="markdown-toc-returning-values-and-arrays">Returning values and arrays</a>        <ol>
          <li><a href="#returning-records" id="markdown-toc-returning-records">Returning records</a></li>
          <li><a href="#returning-columns" id="markdown-toc-returning-columns">Returning columns</a></li>
        </ol>
      </li>
      <li><a href="#reducing" id="markdown-toc-reducing">Reducing</a></li>
      <li><a href="#manipulating-time" id="markdown-toc-manipulating-time">Manipulating Time</a>        <ol>
          <li><a href="#converting-timestamp-formants" id="markdown-toc-converting-timestamp-formants">Converting timestamp formants</a></li>
          <li><a href="#calculating-durations" id="markdown-toc-calculating-durations">Calculating durations</a></li>
          <li><a href="#truncating-or-rounding-timestamps" id="markdown-toc-truncating-or-rounding-timestamps">Truncating or rounding timestamps</a></li>
          <li><a href="#shifting-time" id="markdown-toc-shifting-time">Shifting time</a></li>
          <li><a href="#other-time-manipulations" id="markdown-toc-other-time-manipulations">Other time manipulations</a></li>
        </ol>
      </li>
      <li><a href="#regex" id="markdown-toc-regex">Regex</a>        <ol>
          <li><a href="#the-regexp-package" id="markdown-toc-the-regexp-package">The Regexp Package</a></li>
        </ol>
      </li>
      <li><a href="#the-string-package" id="markdown-toc-the-string-package">The String Package</a></li>
      <li><a href="#combining-data-streams" id="markdown-toc-combining-data-streams">Combining Data Streams</a>        <ol>
          <li><a href="#join" id="markdown-toc-join">Join</a></li>
          <li><a href="#math-across-measurements" id="markdown-toc-math-across-measurements">Math across measurements</a></li>
          <li><a href="#union" id="markdown-toc-union">Union</a></li>
        </ol>
      </li>
      <li><a href="#accessing-external-data-sources" id="markdown-toc-accessing-external-data-sources">Accessing External Data Sources</a>        <ol>
          <li><a href="#the-flux-sql-package" id="markdown-toc-the-flux-sql-package">The Flux SQL package</a></li>
          <li><a href="#csv" id="markdown-toc-csv">CSV</a>            <ol>
              <li><a href="#experimental-csvfrom" id="markdown-toc-experimental-csvfrom">experimental csv.from()</a></li>
              <li><a href="#csvfrom" id="markdown-toc-csvfrom">csv.from()</a></li>
            </ol>
          </li>
          <li><a href="#json" id="markdown-toc-json">JSON</a></li>
        </ol>
      </li>
      <li><a href="#materialized-views-or-downsampling-tasks" id="markdown-toc-materialized-views-or-downsampling-tasks">Materialized Views or Downsampling Tasks</a></li>
    </ol>
  </li>
</ol>

<hr />

<h1 id="querying-with-flux">Querying With Flux</h1>

<p>In the vernacular of Flux, a Flux script is called a “query.” This is despite the fact that you can write valid and useful Flux that doesn’t even query your own data at all. For our purposes now, we can think of writing a query as retrieving targeted data from the storage engine, as opposed to transforming and shaping the data, which will be discussed in detail in the following sections.</p>

<p>As described in the section “Just Enough Flux” in the previous chapter, you can see that a typical simple query involves 3 parts:</p>

<ol>
  <li>The source bucket</li>
  <li>The range of time</li>
  <li>A set of filters</li>
</ol>

<p>Additionally, a query may contain a yield() statement depending on circumstances.</p>

<h2 id="from">from()</h2>

<p>In most cases, a query starts by specifying a bucket to query from using the bucket name:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>In some cases, you may wish to use the bucket’s id instead:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucketID</span><span class="p">:</span> <span class="dl">"</span><span class="s2">497b48e409406cc7</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Typically, developers will address a bucket by its name for a few reasons. First, of course the bucket name is much more readable, the role of the bucket can be encoded in the name. Additionally, there may be times when deleting a bucket and creating a new one with the same name is the most expedient way to delete data. Addressing the bucket by its id has the advantage of being immutable. Someone can change the bucket name, and the query usin the id will continue working.</p>

<p>There are cases that will be described below where you use a different kind of “from”, for example <code class="language-plaintext highlighter-rouge">sql.from()</code> or <code class="language-plaintext highlighter-rouge">csv.from()</code> or <code class="language-plaintext highlighter-rouge">array.from()</code> to bring in data from other sources.</p>

<h2 id="range">range()</h2>

<p>The range function is required directly after <code class="language-plaintext highlighter-rouge">from()</code>and its purpose is to specify the points to include based on their timestamps. <code class="language-plaintext highlighter-rouge">range()</code> has only two parameters.</p>

<h3 id="start-and-stop">start and stop</h3>

<p>An argument for <code class="language-plaintext highlighter-rouge">start</code> is required, whereas stop is optional. In the case where you leave out an argument for <code class="language-plaintext highlighter-rouge">stop</code>, Flux will substitute <code class="language-plaintext highlighter-rouge">now()</code>, which is the current time when execution is scheduled.</p>

<h3 id="now">now()</h3>

<p>now() always returns the time when a Flux script is scheduled to start execution. This has some important implications:</p>

<ol>
  <li>If your script is not run as part of a task, now() will return the time at the very start of execution of the script. If there are any delays, for example due to queuing as a result of excessive load, etc… now() will begin</li>
  <li>If your script is running as part of a task, now() will return the time that  your script was scheduled to run.</li>
  <li>Every call to now() in the script will return the same time.</li>
</ol>

<h4 id="calling-range-with-relative-durations">Calling range() with Relative Durations</h4>

<p>Possibly the most common way to use the range function is to use a start time like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<p>This says to provide all of the data that is available starting five minutes ago. This is inclusive, meaning that any data that is timestamped exactly with the nanosecond exactly five minutes ago will be included. Any data that is five minutes and one nanosecond older or more will not be included.</p>

<p>Conversely, <code class="language-plaintext highlighter-rouge">stop</code> is exclusive. That is to say that if you have any data that is timestamped exactly with the stop argument, it will NOT be included with the results.</p>

<p>So, for example, if there is data that is timestamped precisely 1 minute ago, and you have the following queries, that data will be included in the second query, but not the first.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="nx">m</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">m</span><span class="p">)</span>

<span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<p>When a <code class="language-plaintext highlighter-rouge">stop</code> argument is not supplied Flux simply substitutes <code class="language-plaintext highlighter-rouge">now()</code>. So the following queries are equivalent:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">m</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span> <span class="nx">now</span><span class="p">())</span>

<span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<p>However, this is not true when the start time is in the future. This can happen if your timestamps are, for some reason, post-dated. If your start time is in the future, than now() is, logically before the start time, so this will cause an error:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">1</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<p>Simply support a stop duration that is later than the start to ensure that it works.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">1</span><span class="nx">m</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span> <span class="mi">2</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<p>A duration is a type in Flux. So it is unquoted, and consists of a signed integer and unit. The following duration units are supported:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1ns // 1 nanosecond
1us // 1 microsecond
1ms // 1 millisecond
1s  // 1 second
1m  // 1 minute
1h  // 1 hour
1d  // 1 day
1w  // 1 week
1mo // 1 calendar month
1y  // 1 calendar year
</code></pre></div></div>

<p>So, for example, to select a week’s worth of data starting two weeks in the past, you can use relative durations like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="nx">w</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">w</span><span class="p">)</span>
</code></pre></div></div>

<p>Durations represent a span of time, not a specific time. Therefore, Flux does not understand things like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="mi">5</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<p>That will result in an error because now() returns a specific time, whereas 5m represents a span of time. The types are not compatible. It is possible to do calculations based on times and durations, and this will be covered in detail in a later section.</p>

<p>Durations are not addable, either, so the following will throw an error:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="nx">m</span> <span class="o">+</span> <span class="o">-</span><span class="mi">2</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="defining-ranges-with-integers">Defining Ranges with Integers</h3>

<p>The start and stop parameters also accept integers. For example, you have already seen:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>The integer represents the nanoseconds that have transpired since Thursday, January 1, 1970 12:00:00 AM, GMT, also known as “Unix Time.”</p>

<p>This is extremely useful, as many systems with which you may want to integrate natively use Unix Time. For example, , 12:00 AM, GMT is represented as <code class="language-plaintext highlighter-rouge">1609480800000</code> in Unix time. However, in this case, notice that the time here is represented as <strong>milliseconds</strong>, not nanoseconds. To perform this conversion, simply multiply the milliseconds by 1,000,000, or you can define the precision when you write the data to the database.</p>

<p>So, for all of the data starting from Jan 1, 2021:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">1609480800000000000</span><span class="p">)</span>
</code></pre></div></div>

<p>Unlike durations, integers are, of course, addable, so, to go back a year, this would work:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">365</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">100000000</span><span class="p">)</span>
</code></pre></div></div>

<p>As with durations, if you supply an integer in the future, you must supply a stop time that is later.</p>

<h3 id="defining-ranges-with-times">Defining Ranges with Times</h3>

<p>The third type that is accepted by <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">stop</code> is a time. A time object is expressed as <a href="https://datatracker.ietf.org/doc/html/rfc3339">RFC3339</a> timestamps. For example the following all represent the start of Unix Time:</p>

<ul>
  <li>1970-01-01</li>
  <li>1970-01-01T00:00:00Z</li>
  <li>1970-01-01T00:00:00.000Z</li>
</ul>

<p>So, to get data from the start of some day to now:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">27</span><span class="p">)</span>
</code></pre></div></div>

<p>To get data for some day in the past:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">26</span><span class="p">)</span>
</code></pre></div></div>

<p>By adding the “T” you can get arbitrarily fine grained resolution as well. For example, to skip the first nanosecond:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">27</span><span class="nx">T00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mf">00.0000000001</span><span class="nx">Z</span><span class="p">)</span>
</code></pre></div></div>

<p>If you only care about seconds, you can leave off the fraction:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bucket</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">27</span><span class="nx">T00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">01</span><span class="nx">Z</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="calculating-start-and-stop-times">Calculating Start and Stop Times</h3>

<p>It is possible to compute start and stop times for the range.</p>

<p>&lt;something here about subtracting time and adding time&gt;</p>

<h3 id="start-and-stop-types-can-be-different">Start and Stop Types Can Be Different</h3>

<p>The start and stop parameters do not require the same type to be used. The following work fine.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">operating-results</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="nx">d</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">26</span><span class="p">)</span>

<span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">operating-results</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">1627347600000000000</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">h</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="filter">filter()</h2>

<p>A filter function must either implicitly or explicitly return a boolean value. A filter function operates on each row of each table, and in cases where there return value is <code class="language-plaintext highlighter-rouge">true</code>, the row is retained in the table. In cases where the return value is <code class="language-plaintext highlighter-rouge">false</code>, the row is removed from the table.</p>

<h3 id="filter-basics">Filter Basics</h3>

<p>A very common filter is to filter by measurement.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>The actual function is the argument for the <code class="language-plaintext highlighter-rouge">fn</code> parameter:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span>
</code></pre></div></div>

<p>“(r)” is the parameter list. A filter function always expects to only have a single parameter, and for it to be called “r.” Then the function body is a simple boolean expression that will evaluate to true or false. This function will return true when the _measurement for a row is “sensors” and so therefore the function will emit a stream of tables where all of the data has the sensor measurement.</p>

<p>Naturally, you can omit the sensors measurement in the same manner:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">!=</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="anatomy-of-a-row">Anatomy of a Row</h3>

<p>When read from the storage engine and passed into the filter function, by default, before being transformed by other functions, every row has the same essential object model. Flux uses a leading underscore (“<code class="language-plaintext highlighter-rouge">_</code>”) to delineate reserved member names. In Flux, each member of a row is called a “column,” or sometimes a “field” depending on the context.</p>

<p>Drawing from a row of the example air sensor data, we can see how this is represented as a row in Flux.</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>fieldname1
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
</table>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">r._measurement</code> is a string that is the measurement which defines the table that row is saved into.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">r._field</code> is a string that is the name of the field which defines the table that the row is saved into.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">r._value</code> is the actual value of the field.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">r._time</code> is the time stamp of the row.</p>
  </li>
</ul>

<p>Additionally, each tag value is accessible by its tag name. For example, r.tag1, which in this example has a value of “tagvalue1.”</p>

<p>Finally, there are two additional context specific members added. These members are determined by the query, not the underlying data:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">r._start</code> is the start time of the range() in the query.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">r._stop()</code> is the stop time of the range() in the query.</p>
  </li>
</ul>

<p>For example, if you query with a range of 5  minutes in the past (<code class="language-plaintext highlighter-rouge">range(start: -5m)</code>), you will get a <code class="language-plaintext highlighter-rouge">_start</code> and <code class="language-plaintext highlighter-rouge">_stop</code> 5 minutes apart:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>fieldname1
   </td>
   <td>1.0
   </td>
   <td>2021:08:20T20:00:000000000Z
   </td>
   <td>2021:08:20T20:05:000000000Z
   </td>
   <td>rfc3339time1
   </td>
  </tr>
</table>

<p>When you are filtering, you therefore have all of these columns to work from.</p>

<p><img src="/time-to-awesome/assets/images/image-27.png" alt="drawing" /></p>

<h3 id="filtering-measurements">Filtering Measurements</h3>

<p>A discussed in the data model section above, a measurement is the highest order aggregation of data inside a bucket. It is, therefore, the most common subject, and typically first, filter, as it filters out the most irrelevant data in a single statement.</p>

<p>Additionally, every table written by the storage engine has exactly one measurement, so the storage engine can quickly find the relevant tables and return them.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Given the two tables below, only the first will be returned if the preceding filter is applied:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>2i
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement2
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement2
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h3 id="filtering-tags">Filtering Tags</h3>

<p>Multiple measurements can share the same tag set. As such, filtering by tag is sometimes secondary to filtering by measurement. The storage engine keeps track of where the tables with different tags for specific measurements are, so filtering by tag is typically reasonably fast.</p>

<p>The following tables have different measurements, but the same tag values, so the following filter will return both tables:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>2i
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement2
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement2
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>If you only want one measurement with that tag value, you can simply include both filters. The following will return only the first table:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="filtering-by-field">Filtering by Field</h3>

<p>Filtering by field is extremely common, and also very fast, as fields are part of the group key of tables. Given the following table, if you are interested in records in field1 in measurement1, you can simply query like so, and get back only the first table:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>2i
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field2
   </td>
   <td>2.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement2
   </td>
   <td>tagvalue1
   </td>
   <td>field2
   </td>
   <td>3.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement2
   </td>
   <td>tagvalue1
   </td>
   <td>field2
   </td>
   <td>4.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>However, this won’t work for field2, as that field name exists in measurement2 as well. Simply include a measurement filter as well:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>This will return only the first table.</p>

<h3 id="filter-by-exists">Filter by Exists</h3>

<p>There may be circumstances where you wish to only operate on tables that contain a specific tag value. You can use <code class="language-plaintext highlighter-rouge">exists</code> or <code class="language-plaintext highlighter-rouge">not exists</code> for this.</p>

<p>The following will ensure that only tables which contain the “tag1” are returned:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">exists</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span><span class="p">)</span>
</code></pre></div></div>

<p>Similarly, if you want to retain only tables that do not conain the “tag1”, use:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">not</span> <span class="nx">exists</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span><span class="p">)</span>
</code></pre></div></div>

<p>To illustrate that point, take the following two tables. Each record has a different time stamp. The second table differs only in that those points were recorded with an additional tag, “tag2”.</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>2i
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>3i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>4i
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>The following query will return the first table:</p>

<table>
  <tbody>
    <tr>
      <td>&gt;  <code class="language-plaintext highlighter-rouge">filter(fn: (r) =&gt; not exists r.tag2)</code></td>
    </tr>
  </tbody>
</table>

<p>If you only wanted to return the second table with the points that lack the “tag2”, you can use <code class="language-plaintext highlighter-rouge">not exists</code>. Instead you must must drop that column all together. We’ll cover that in more detail in later sections.</p>

<h3 id="filtering-by-field-value">Filtering by Field Value</h3>

<p>Filtering by measurement(s), tag(s), or field(s) remove entire tables from the response. You can also filter out individual rows in tables. The most common way to do this is to filter by value.</p>

<p>For example, if we take our few rows of air sensor data, and first filter by field:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">fieldname1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>We are left with these two tables.</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>3.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>3.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>If we also add a filter for value, we can filter out individual rows. For example:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&lt;</span> <span class="mf">2.0</span><span class="p">)</span>
</code></pre></div></div>

<p>Will result in the following stream of tables being emitted:. Note that the first table has dropped a single row:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>3.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>3.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>The row where the field value was less than 2 was dropped.</p>

<h3 id="compound-filters">Compound Filters</h3>

<p>Boolean expressions in Flux can be compounded with “<code class="language-plaintext highlighter-rouge">or</code>” and “<code class="language-plaintext highlighter-rouge">and</code>.” For example, to retrieve all the tables with either the fields temperature or humidity, but no others, you use:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">filed2</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>You can aggregate with <code class="language-plaintext highlighter-rouge">or</code> using different members of<code class="language-plaintext highlighter-rouge"> r</code> if needed:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">exist</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span><span class="p">)</span>
</code></pre></div></div>

<p>You can use <code class="language-plaintext highlighter-rouge">and</code> as well:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>However, this is less commonly used because it is equivalent to simply supplying two filters. The follow two filters is equivalent to, and arguably easier to read and modify:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">sensor_id</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="regular-expressions">Regular Expressions</h3>

<p>Sometimes your code will need to find substrings or even more complex pattern matching. Flux supports regular expressions for this purpose.</p>

<p>There are two regex operators in Flux, “<code class="language-plaintext highlighter-rouge">=~</code>” for matches, and “<code class="language-plaintext highlighter-rouge">!~</code>” for does not match. The operators expect a string on the left side, and regular expression on the right. You define a regular expression object by surrounding your regex in “<code class="language-plaintext highlighter-rouge">/</code>.” For example to find all values of tag1 that include the string “tag”. You can use:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span> <span class="o">=~</span> <span class="sr">/tag/</span><span class="p">)</span>
</code></pre></div></div>

<p>In this case, the regex operator is “matches”, i.e. find all of the tag1 values that match the regex, and the regex itself is tag. Every table where the tag1 tag value contains the string “tag” will be returned.</p>

<p>To exclude all such tables, simply use the “does not match” version:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span> <span class="o">!~</span> <span class="sr">/tag/</span><span class="p">)</span>
</code></pre></div></div>

<p>Flux supports the full range of regex expressiveness.  To match the pattern of 3 capital letters and 4 digits:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">=~</span> <span class="sr">/</span><span class="se">[</span><span class="sr">A-Z</span><span class="se">]{3}[</span><span class="sr">0-9</span><span class="se">]{4}</span><span class="sr">/</span><span class="p">)</span>
</code></pre></div></div>

<p>These operators work on any field that is of type string. So you can use this to filter by measurement, field name, and even field value when the field value is a string type.</p>

<p>However, it is important to note that the Flux storage engine cannot leverage the layout of tables when using regular expressions, so it must often scan every table, or even every row, to find matches. This can cause your queries to run much more slowly. Therefore, if you are regularly using regular expressions to filter your data, consider adding additional tags instead.</p>

<h4 id="if-then-else">If, Then, Else</h4>

<p>Flux also supports “if, then, else” statements. This can be useful if you want to express more complex conditions in a readable manner.</p>

<p>The following two filters are equivalent:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&lt;</span> <span class="mf">2.0</span> <span class="nx">then</span> <span class="kc">true</span> <span class="k">else</span>  <span class="kc">false</span><span class="p">)</span>
<span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span>
</code></pre></div></div>

<p>Naturally, you can rather return the result of a boolean expression:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">then</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&lt;</span> <span class="mf">2.0</span> <span class="k">else</span>  <span class="kc">false</span><span class="p">)</span>
</code></pre></div></div>

<p>If then else can also be chained:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> 
<span class="nx">then</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&lt;</span> <span class="mf">2.0</span> 
<span class="k">else</span> <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">tag1</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue2</span><span class="dl">"</span>
	<span class="nx">then</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&lt;</span> <span class="mf">3.0</span>
<span class="k">else</span> <span class="kc">false</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="types-in-comparisons">Types In Comparisons</h3>

<p>As a strongly typed language, in general, Flux does not support comparisons between variables with different types.</p>

<p>Flux does support comparing integers to floats:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">int</span><span class="p">(</span> <span class="nx">v</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span>
</code></pre></div></div>

<p>But does not support comparing other data types. For example, this will cause an error:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">1</span><span class="dl">"</span> <span class="o">==</span> <span class="mf">1.0</span>
<span class="nx">unsupported</span> <span class="nx">binary</span> <span class="nx">expression</span> <span class="nx">string</span> <span class="o">==</span> <span class="nx">float</span>
</code></pre></div></div>

<p>Times can be compared:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">12</span><span class="nx">T19</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mf">00.000</span><span class="nx">Z</span> <span class="o">&lt;</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">12</span><span class="nx">T19</span><span class="p">:</span><span class="mi">39</span><span class="p">:</span><span class="mf">00.000</span><span class="nx">Z</span>
</code></pre></div></div>

<p>But cannot be compared to, for example, Unix Time integers:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">12</span><span class="nx">T19</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mf">00.000</span><span class="nx">Z</span> <span class="o">&lt;</span> <span class="mi">1627923626000000000</span>
<span class="nx">unsupported</span> <span class="nx">binary</span> <span class="nx">expression</span> <span class="nx">time</span> <span class="o">&lt;</span> <span class="nx">int</span>
</code></pre></div></div>

<p>But this can be done with some explicit casting:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">uint</span><span class="p">(</span><span class="nx">v</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">12</span><span class="nx">T19</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mf">00.000</span><span class="nx">Z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1627923626000000000</span>
</code></pre></div></div>

<p>Details on how to cast time between different formats so that you calculate and compare time and durations from different formats is covered in detail in a future section.</p>

<h2 id="queries-and-the-data-model">Queries and the Data Model</h2>

<p>This section focused on queries that only found and filtered data. As such, the results are a subset of tables and a subset of rows of the tables stored in the storage engine. There may be few tables, but the only change to the tables returned is that there may be rows filtered out.</p>

<p>In other words, the pattern<code class="language-plaintext highlighter-rouge"> from() |&gt; range() |&gt; filter() </code>will not transform your data as stored on disk other than perhaps filtering it. The next section will go further and delve into many of the options for transforming the shape of the data.</p>

<h1 id="flux-data-transformations">Flux Data Transformations</h1>

<p>In addition to retrieving data from disk, Flux is a powerful data transformation tool. You can use Flux to shape your data however needed, as well as apply powerful mathematical transformations to your data as well.</p>

<h2 id="grouping">Grouping</h2>

<p>To review, when you write data to InfluxDB, the storage engine persists it in tables, where each table is defined by a “group key.” The group key used to persist the data is a measurement name, a unique set of tag values, and a field name.</p>

<p>Consider the following example of 6 tables with two rows each, all containing the same measurement, but there are:</p>

<ul>
  <li>Two tags, with a total of 5 tag values
    <ul>
      <li>tag1 has the 2 tag values:
        <ul>
          <li>tagvalue1</li>
          <li>tagvalue4</li>
        </ul>
      </li>
      <li>tag2 has 3 tag values:
        <ul>
          <li>tagvalue2</li>
          <li>tagvalue3</li>
          <li>tagvalue5</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Two fields
    <ul>
      <li>field1</li>
      <li>field2</li>
    </ul>
  </li>
</ul>

<p>Where the line protocol would look like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue3</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue3</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue3</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue3</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue5</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue5</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue5</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue5</span> <span class="nx">field1</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue3</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue3</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue3</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue3</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue5</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue5</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>

<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue5</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">0.0</span> <span class="nx">unixtime1</span>
<span class="nx">measurement</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue4</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="nx">tagvalue5</span> <span class="nx">field2</span><span class="o">=</span><span class="mf">1.0</span> <span class="nx">unixtime2</span>
</code></pre></div></div>

<p>I encourage you to replace the metasyntax timestamps with actual unix timestamps and try out the grouping on your own. You can use can use this <a href="https://www.unixtimestamp.com/">unix timestamp converter</a> to get two unix timestamps of your choice or you can use the following two values:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1628229600000000000 (or 2021-08-06T06:00:00.000000000Z)</code></li>
  <li><code class="language-plaintext highlighter-rouge">1628229900000000000 (or 2021-08-06T06:05:00.000000000Z)</code></li>
</ul>

<p>Then write the data to InfluxDB with the CLI, API, or InfluxDB UI.</p>

<p>The following query will return the following 12 separate tables:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that an extra row has been added to each table to denote if each column is part of the group key. The start column has been removed from the table response for simplicity. The table column has been added to help you keep track of the number of columns Remember, the group key for the table column is an exception and it’s always set to false. The group key for the table is set to false because users can’t directly change the table number. The table record will always be the same across rows even though the group key is set to false.</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Aaa</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>6
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>6
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>7
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>7
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>8
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>8
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>9
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>9
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>10
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>10
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>11
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>11
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>By default each field name will be in a separate table, and then there are 6 unique combinations of tag values grouped with each field:</p>

<ul>
  <li>tagvalue1 and tagvalue2</li>
  <li>tagvalue4 and tagvalue2</li>
  <li>tagvalue1 and tagvalue3</li>
  <li>tagvalue4 and tagvalue3</li>
  <li>tagvalue1 and tagvalue5</li>
  <li>tagvalue4 and tagvalue5</li>
</ul>

<h3 id="group">group()</h3>

<p>The group() function can be to redefine the group keys, which will then result in regrouping the tables. We can begin by examining how defined the group key to a single column can affect the tables.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<p>We know that there are 2 tag values for tag1 (tagvalue1 and tagvalue4), so we can predict that there will be two tables after the grouping:</p>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>If we group by both tags, then we can predict that their will then be 6 tables because, as described above, there are three unique combinations of tag values:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">tag2</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Grouping by field alone, we can predict that we will see a total of 2 tables, because the data set has only 2 field names.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Any combination of columns can be used for grouping depending on your purposes. For example, we can ask for tables for each field with each value for tag1. We can predict that there will be 4 such tables, because there are two fields and two tag values for tag1:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h3 id="group-and-type-conflicts">group() and Type Conflicts</h3>

<p>In the above example, the values for field1 and field2 were always floats. Therefore, when grouping both of those fields into the same tables, it worked. However, recall that a column in InfluxDB can only have one type.</p>

<p>Given the following two tables which differ only in that they have a different field name, and their field values have a different type:</p>

<table>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>An attempt to group these two tables into the same table will result in the following error:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
<span class="nx">schema</span> <span class="nx">collision</span><span class="p">:</span> <span class="nx">cannot</span> <span class="nx">group</span> <span class="nx">integer</span> <span class="nx">and</span> <span class="nx">float</span> <span class="nx">types</span> <span class="nx">together</span>
</code></pre></div></div>

<p>The simplest way to address this is to convert all of the values to floats using the <code class="language-plaintext highlighter-rouge">toFloat() </code>function. This function simply converts the value field for each record into a float if possible.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">toFloat</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
</code></pre></div></div>

<table>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h3 id="dropkeep">drop()/keep()</h3>

<p>Another way to affect the group keys is to simply remove columns that are in the group key using the<code class="language-plaintext highlighter-rouge"> drop()</code> or<code class="language-plaintext highlighter-rouge"> keep()</code> functions. These two functions operate in the same manner, it’s just a matter of supplying a list of columns to eliminate vs. preserve.</p>

<p>Note that the following are equivalent:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">drop</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">tag2</span><span class="dl">"</span><span class="p">])</span>

<span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">keep</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<p>In both cases the effect is to remove both of the tag columns from the table. Because tags are always in the group key by default, this change will leave only <code class="language-plaintext highlighter-rouge">_measurement</code> and<code class="language-plaintext highlighter-rouge"> _field</code> in the group key. Because there is only one measurement, this will result in grouping solely by <code class="language-plaintext highlighter-rouge">_field</code>.</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:00.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:01.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:02.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:03.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:04.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:05.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:00.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:01.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:02.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:03.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:04.000000000Z
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:05.000000000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:00.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:01.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:02.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:03.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:04.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:05.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:00.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:01.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:02.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:03.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T21:22:04.000000000Z
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T21:22:05.000000000Z
   </td>
  </tr>
</table>

<p>Note that <code class="language-plaintext highlighter-rouge">drop()</code> and <code class="language-plaintext highlighter-rouge">keep()</code> are both susceptible to the same type conflicts that can cause errors with <code class="language-plaintext highlighter-rouge">group()</code>.</p>

<h3 id="rename">rename()</h3>

<p>Rename does not change the group key, but simply changes the names of the columns. It works by providing the function with a mapping of old column names to new column names.</p>

<p>Given the following very simple table:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
</table>

<p>The following code simply renames the <code class="language-plaintext highlighter-rouge">tag1</code> column:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">rename</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">{</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">tag2</span><span class="dl">"</span><span class="p">})</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
</table>

<p>You can rename any column which can be very useful for things like formatting data to present to users. However, renaming can have some unintended consequences. For example, if you rename the <code class="language-plaintext highlighter-rouge">_value</code> column, certain functions will have surprising results or fail because they operate on <code class="language-plaintext highlighter-rouge">_value</code>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">rename</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">{</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">astring</span><span class="dl">"</span><span class="p">})</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>astring
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
</table>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">rename</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">{</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">astring</span><span class="dl">"</span><span class="p">})</span>
<span class="o">|&gt;</span> <span class="nx">toFloat</span><span class="p">()</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>astring
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>
   </td>
   <td>1i
   </td>
   <td>rfc3339time1
   </td>
  </tr>
</table>

<p>In this case, because there was no <code class="language-plaintext highlighter-rouge">_value</code> column to convert from, the <code class="language-plaintext highlighter-rouge">toFloat()</code> method had no data to place in the <code class="language-plaintext highlighter-rouge">_value</code> column that it creates.</p>

<h3 id="creating-a-single-table-or-ungrouping">Creating a Single Table or Ungrouping</h3>

<p>Finally, it is possible to put all of the data into a single table assuming that you avoid type conflicts. This is achieved by using the group() function with no arguments. Basically making the group key empty, so all of the data gets grouped into a single table. This is effectively the same as ungrouping.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue3
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>0.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue5
   </td>
   <td>1.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h2 id="windowing">Windowing</h2>

<p>Windowing is when you group data by the start and stop times with the window() function. In previous sections the _start and _stop columns have been omitted for simplicity because they typically represent the start and stop times defined in the range function.  To illustrate let’s filter our data for the first two tables and include the _start and _stop columns:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span><span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T3</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue4</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag2</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue2</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">)</span>  
</code></pre></div></div>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T01:00:00
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T02:00:00
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T01:00:00
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T02:00:00
   </td>
  </tr>
</table>

<p>If you apply the window() function the values in the _start and _stop column will change to reflect the defined window period:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span><span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T3</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue4</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag2</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue2</span><span class="dl">"</span><span class="p">)</span> 
  <span class="o">|&gt;</span> <span class="nb">window</span><span class="p">(</span><span class="nx">period</span><span class="p">:</span> <span class="mi">90</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T01:00:00
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T01:00:00
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T02:00:00
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T02:00:00
   </td>
  </tr>
</table>

<p>Windowing is performed for two main reasons:</p>

<ol>
  <li>To aggregate data across fields or tags with timestamps in the same period.</li>
  <li>To transform high precision series into a lower resolution aggregation.</li>
</ol>

<p>To aggregate data across fields or tags with similar timestamps, you can first apply the window() function like above, then you can group your data by the _start times. Now data that’s in the same window will be in the same table, so you can apply an aggregation after:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span><span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T3</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue4</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag2</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue2</span><span class="dl">"</span><span class="p">)</span> 
  <span class="o">|&gt;</span> <span class="nb">window</span><span class="p">(</span><span class="nx">period</span><span class="p">:</span> <span class="mi">90</span><span class="nx">m</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_start</span><span class="dl">"</span><span class="p">],</span> <span class="nx">mode</span><span class="p">:</span><span class="dl">"</span><span class="s2">by</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">after group</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">sum</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">after sum</span><span class="dl">"</span><span class="p">)</span> 
</code></pre></div></div>

<p>The result after the first yield, “after group” looks like:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T01:00:00
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T01:00:00
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T02:00:00
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue4
   </td>
   <td>tagvalue2
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T02:00:00
   </td>
  </tr>
</table>

<p>The result after the first yield, “after sum” looks like:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>0.0
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_value
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>2021-08-17T03:00:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>2.0
   </td>
  </tr>
</table>

<p>The sum() function is an aggregator so the _time column is removed because there isn’t a timestamp associated with the sum of two values. Keep in mind that in this example the timestamps in the _time column in the “after group” output happen to be the same, but this aggregation across fields within time windows would work even if the timestamps were different. The _time column isn’t a part of the group key.</p>

<h2 id="windowing-and-aggregatewindow">Windowing and aggregateWindow()</h2>

<p>The most common reason for using the window() function is to transform high precision data into lower resolution aggregations. Simply applying a sum() after a window would calculate the sum of the data for each series within the window period. To better illustrate window() function let’s look at the following simplified input data:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>0.0
   </td>
   <td>2021-08-17T00:30:00
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-08-17T01:00:00
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>2021-08-17T01:30:00
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>3.0
   </td>
   <td>2021-08-17T02:00:00
   </td>
  </tr>
</table>

<p>The following query would return two tables with the sum for all the points in the series within a 90 min window:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span><span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T3</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">)</span> 
  <span class="o">|&gt;</span> <span class="nb">window</span><span class="p">(</span><span class="nx">period</span><span class="p">:</span> <span class="mi">90</span><span class="nx">m</span><span class="p">)</span> 
  <span class="o">|&gt;</span> <span class="nx">sum</span><span class="p">()</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>2021-08-17T00:00:00
   </td>
   <td>2021-08-17T01:30:00
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>5.0
   </td>
  </tr>
</table>

<p>By using the window() function following an aggregation function, we’ve  reduced the number of points in our series by half. We’ve transformed a higher resolution data set into a lower resolution sum over 90 min windows.  This combination of functions introduces another similar function, the aggregateWindow() function.</p>

<p>The aggregateWindow() function windows data and applies an aggregate function or selector function to the data. You can think of the aggregateWindow() function as being a combination of the window() function followed by an aggregate or selector function. The difference between the window() function and the aggregateWindow() function is that the aggregateWindow() function applies a group to your data at the end so that your lower resolution aggregations aren’t separated into different tables by their window period. Instead all lower resolution aggregations are grouped together. In other words, these two queries are equivalent:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">query1</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span><span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T3</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field2</span><span class="dl">"</span> <span class="p">)</span> 
  <span class="o">|&gt;</span> <span class="nb">window</span><span class="p">(</span><span class="nx">period</span><span class="p">:</span> <span class="mi">90</span><span class="nx">m</span><span class="p">)</span> 
  <span class="o">|&gt;</span> <span class="nx">sum</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">],</span><span class="nx">mode</span><span class="p">:</span><span class="dl">"</span><span class="s2">by</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">query2</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">,</span> <span class="nx">stop</span><span class="p">:</span><span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T3</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field2</span><span class="dl">"</span> <span class="p">)</span> 
  <span class="o">|&gt;</span> <span class="nx">aggregateWindow</span><span class="p">(</span><span class="nx">every</span><span class="p">:</span> <span class="mi">90</span><span class="nx">m</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">sum</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="real-world-data-example-of-grouping">Real World Data Example of Grouping</h2>

<p>Having reviewed grouping and aggregation using clean instructive data, it is worthwhile to review the concepts again, but looking at real world data. The NOAA buoy data is a good sample set to look at due to its complexity.</p>

<p>For example, to take a closer look at wind speeds, the following query will simply return all of the tables with the field “wind_speed_mps.”</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>This query reads back data for a total of around 628 tables (this value will be more or less depending on the time range queried). Due to the combination of tag values and the restricted time range, most of the tables returned have only a single row. Here are the first few rows as an example.</p>

<h3 id="default-grouping">Default Grouping</h3>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:35:12.486582468Z
   </td>
   <td>2021-08-03T15:35:12.486582468Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
9</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
46303</p>

   </td>
   <td>Southern Georgia Strait
   </td>
   <td>Environment and Climate Change Canada
   </td>
   <td>International Partners
   </td>
   <td>buoy
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:35:12.486582468Z
   </td>
   <td>2021-08-03T15:35:12.486582468Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
7.7</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>FWYF1
   </td>
   <td>Fowey Rock, FL
   </td>
   <td>NDBC
   </td>
   <td>NDBC Meteorological/Ocean
   </td>
   <td>fixed
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:35:12.486582468Z
   </td>
   <td>2021-08-03T15:35:12.486582468Z
   </td>
   <td>2021-08-03T04:30:00Z
   </td>
   <td><p style="text-align: right">
2.1</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>GELO1
   </td>
   <td>Geneva on the Lake Light, OH
   </td>
   <td>NWS Eastern Region
   </td>
   <td>IOOS Partners
   </td>
   <td>fixed
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:35:12.486582468Z
   </td>
   <td>2021-08-03T15:35:12.486582468Z
   </td>
   <td>2021-08-03T05:18:00Z
   </td>
   <td><p style="text-align: right">
4.6</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>FMOA1
   </td>
   <td>8734673 - Fort Morgan, AL
   </td>
   <td>NOAA NOS PORTS
   </td>
   <td>NOS/CO-OPS
   </td>
   <td>fixed
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:35:12.486582468Z
   </td>
   <td>2021-08-03T15:35:12.486582468Z
   </td>
   <td>2021-08-03T05:18:00Z
   </td>
   <td><p style="text-align: right">
6.7</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>TXPT2
   </td>
   <td>8770822 - Texas Point, Sabine Pass, TX
   </td>
   <td>TCOON
   </td>
   <td>IOOS Partners
   </td>
   <td>fixed
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:35:12.486582468Z
   </td>
   <td>2021-08-03T15:35:12.486582468Z
   </td>
   <td>2021-08-03T05:30:00Z
   </td>
   <td><p style="text-align: right">
2</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
45170</p>

   </td>
   <td>Michigan City Buoy, IN
   </td>
   <td>Illinois-Indiana Sea Grant and Purdue Civil Engineering
   </td>
   <td>IOOS Partners
   </td>
   <td>buoy
   </td>
  </tr>
</table>

<h3 id="group-1">group()</h3>

<p>The group() function can be to redefine the group keys, which will then result in entirely different tables. For example:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<p>This call to <code class="language-plaintext highlighter-rouge">group()</code> tells Flux to make only the single column station_type to be in the set of columns in the group key. station_type has four possible values (“buoy”,”fixed”, “oilrig”, and “other”). As a result, we know that the results will then contain exactly 4 tables. Here are excerpts from those tables:</p>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
3</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
22102</p>

   </td>
   <td>
   </td>
   <td>Korean Meteorological Administration
   </td>
   <td>International Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
4</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
22103</p>

   </td>
   <td>
   </td>
   <td>Korean Meteorological Administration
   </td>
   <td>International Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
2</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
22104</p>

   </td>
   <td>
   </td>
   <td>Korean Meteorological Administration
   </td>
   <td>International Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
6</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
22105</p>

   </td>
   <td>
   </td>
   <td>Korean Meteorological Administration
   </td>
   <td>International Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
5</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
22106</p>

   </td>
   <td>
   </td>
   <td>Korean Meteorological Administration
   </td>
   <td>International Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T04:30:00Z
   </td>
   <td><p style="text-align: right">
5</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>32ST0
   </td>
   <td>Stratus
   </td>
   <td>Woods Hole Oceanographic Institution
   </td>
   <td>IOOS Partners
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
4.1</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
62103</p>

   </td>
   <td>Channel Lightship
   </td>
   <td>UK Met Office
   </td>
   <td>International Partners
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T04:45:00Z
   </td>
   <td><p style="text-align: right">
0</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>ACXS1
   </td>
   <td>Bennetts Point, ACE Basin Reserve, SC
   </td>
   <td>National Estuarine Research Reserve System
   </td>
   <td>NERRS
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:30:00Z
   </td>
   <td><p style="text-align: right">
5.7</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>AMAA2
   </td>
   <td>East Amatuli Island Light, AK
   </td>
   <td>NDBC
   </td>
   <td>NDBC Meteorological/Ocean
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T04:30:00Z
   </td>
   <td><p style="text-align: right">
0</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>ANMN6
   </td>
   <td>Field Station, Hudson River Reserve, NY
   </td>
   <td>National Estuarine Research Reserve System
   </td>
   <td>NERRS
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
2.6</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
62114</p>

   </td>
   <td>Tartan &quot;A&quot; AWS
   </td>
   <td>Private Industry Oil Platform
   </td>
   <td>International Partners
   </td>
   <td>oilrig
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
2.1</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
62121</p>

   </td>
   <td>Carrack AWS
   </td>
   <td>Private Industry Oil Platform
   </td>
   <td>International Partners
   </td>
   <td>oilrig
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
1.5</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
62144</p>

   </td>
   <td>Clipper AWS
   </td>
   <td>Private Industry Oil Platform
   </td>
   <td>International Partners
   </td>
   <td>oilrig
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
2.6</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
62145</p>

   </td>
   <td>North Sea
   </td>
   <td>Private Industry Oil Platform
   </td>
   <td>International Partners
   </td>
   <td>oilrig
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
1.5</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
62146</p>

   </td>
   <td>Lomond AWS
   </td>
   <td>Private Industry Oil Platform
   </td>
   <td>International Partners
   </td>
   <td>oilrig
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:20:00Z
   </td>
   <td><p style="text-align: right">
9</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41002</p>

   </td>
   <td>SOUTH HATTERAS - 225 NM South of Cape Hatteras
   </td>
   <td>NDBC
   </td>
   <td>NDBC Meteorological/Ocean
   </td>
   <td>other
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:20:00Z
   </td>
   <td><p style="text-align: right">
6</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41009</p>

   </td>
   <td>CANAVERAL 20 NM East of Cape Canaveral, FL
   </td>
   <td>NDBC
   </td>
   <td>NDBC Meteorological/Ocean
   </td>
   <td>other
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:20:00Z
   </td>
   <td><p style="text-align: right">
12</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41010</p>

   </td>
   <td>CANAVERAL EAST - 120NM East of Cape Canaveral
   </td>
   <td>NDBC
   </td>
   <td>NDBC Meteorological/Ocean
   </td>
   <td>other
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:20:00Z
   </td>
   <td><p style="text-align: right">
2</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41013</p>

   </td>
   <td>Frying Pan Shoals, NC
   </td>
   <td>NDBC
   </td>
   <td>NDBC Meteorological/Ocean
   </td>
   <td>other
   </td>
  </tr>
  <tr>
   <td>2021-08-03T03:50:09.78158678Z
   </td>
   <td>2021-08-03T15:50:09.78158678Z
   </td>
   <td>2021-08-03T05:20:00Z
   </td>
   <td><p style="text-align: right">
8</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41040</p>

   </td>
   <td>NORTH EQUATORIAL ONE- 470 NM East of Martinique
   </td>
   <td>NDBC
   </td>
   <td>NDBC Meteorological/Ocean
   </td>
   <td>other
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>

<p>You may note that _start and _stop are also in the group key. Remember that these columns are added by Flux to specify the time range of the data being returned. For data from a single query, these values will always be the same for all rows, and thus will not change the number of tables.</p>

<p>You can further group by including multiple columns. For example, one can add station_pgm (the name of the partner organization providing the data) to the group key as well:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">station_pgm</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<p>Now we can see in the returned tables, that because station_type and station_pgm are in the group key, the unique combinations of those values are in separate tables. For example IOOS Partners have both buoy stations and fixed stations, so those different station types are grouped into separate tables.</p>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T05:08:00Z
   </td>
   <td><p style="text-align: right">
2</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41033</p>

   </td>
   <td>Fripp Nearshore, SC (FRP2)
   </td>
   <td>CORMP
   </td>
   <td>IOOS Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T05:08:00Z
   </td>
   <td><p style="text-align: right">
2</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41037</p>

   </td>
   <td>Wrightsville Beach Offshore, NC (ILM3)
   </td>
   <td>CORMP
   </td>
   <td>IOOS Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
7</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41052</p>

   </td>
   <td>South of St. John, VI
   </td>
   <td>Caribbean Integrated Coastal Ocean Observing System (CarICoos)
   </td>
   <td>IOOS Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
4</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41053</p>

   </td>
   <td>San Juan, PR
   </td>
   <td>Caribbean Integrated Coastal Ocean Observing System (CarICoos)
   </td>
   <td>IOOS Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T05:00:00Z
   </td>
   <td><p style="text-align: right">
6</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td><p style="text-align: right">
41056</p>

   </td>
   <td>Vieques Island, PR
   </td>
   <td>Caribbean Integrated Coastal Ocean Observing System (CarICoos)
   </td>
   <td>IOOS Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
  </tr>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_measurement
   </td>
   <td>station_id
   </td>
   <td>station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T04:30:00Z
   </td>
   <td><p style="text-align: right">
5</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>32ST0
   </td>
   <td>Stratus
   </td>
   <td>Woods Hole Oceanographic Institution
   </td>
   <td>IOOS Partners
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T04:30:00Z
   </td>
   <td><p style="text-align: right">
7</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>41NT0
   </td>
   <td>NTAS - Northwest Tropical Atlantic
   </td>
   <td>Woods Hole Oceanographic Institution
   </td>
   <td>IOOS Partners
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T05:18:00Z
   </td>
   <td><p style="text-align: right">
3.1</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>ANPT2
   </td>
   <td>8775241 - Aransas, Aransas Pass, TX
   </td>
   <td>TCOON
   </td>
   <td>IOOS Partners
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T05:30:00Z
   </td>
   <td><p style="text-align: right">
4.1</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>APNM4
   </td>
   <td>Alpena Harbor Light, Alpena, MI
   </td>
   <td>GLERL
   </td>
   <td>IOOS Partners
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-03T04:11:46.849771273Z
   </td>
   <td>2021-08-03T16:11:46.849771273Z
   </td>
   <td>2021-08-03T04:40:00Z
   </td>
   <td><p style="text-align: right">
1.5</p>

   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>BHRI3
   </td>
   <td>Burns Harbor, IN
   </td>
   <td>NWS Central Region
   </td>
   <td>IOOS Partners
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>

<h3 id="dropkeep-1">drop()/keep()</h3>

<p>Another way to affect the group keys is to simply remove columns that are in the group key using the<code class="language-plaintext highlighter-rouge"> drop()</code> or<code class="language-plaintext highlighter-rouge"> keep()</code> functions. These two functions operate in the same manner, it’s just a matter of supplying a list of columns to eliminate vs. preserve.</p>

<p>The following are equivalent:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">drop</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_start</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_stop</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">station_name</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">station_owner</span><span class="dl">"</span><span class="p">])</span>

<span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">keep</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">station_id</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">station_pgm</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<p>The first thing to notice is that applying keep() cleans up the data dramatically, making it much easier to read and work with. A common use of drop() and keep() therefore, is just to make the data more readable.</p>

<p>However, if you drop a column that is in the group key, this will impact the tables. For example, the query above results in 559 tables, because it leaves station_id, station_pgm, and station_type all in the group key, and the combination of those unique sets of tag values, adds up to 559 different combinations.</p>

<p>If we also drop the station_id, this drops the tag with the most unique values:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">drop</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_start</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_stop</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">station_name</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">station_owner</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">station_id</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<p>This results in a total of only 12 tables. There are a total of 6 station_pgm values, each with about 2 station_types, so only a total of 12 tables.</p>

<h3 id="grouping-and-type-conflicts">Grouping and Type Conflicts</h3>

<p>It is possible using group(), drop(), keep() or other functions to remove _field from the group key. Remember that Flux is strongly typed, so a column cannot contain values of multiple types. As a result, it is possible to create errors when grouping. Because tag values are always strings, and _start, _stop, and _time are always times, this problem almost always happens due to _fields.</p>

<p>So, if we rerun one the queries above without filtering the field using the following:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">24</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">station_pgm</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<p>Part of the output is an error message:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schema collision: cannot group float and string types together
</code></pre></div></div>

<p>This happens because some of the fields (station_met, station_currents, station_waterquality, station_dart) are all strings, so cannot be grouped into tables with the fields that are floats.</p>

<p>One way to solve this is to keep the _field column in the group key:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">24</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">station_pgm</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<p>Though of course this will result in creating many more tables.</p>

<h3 id="creating-a-single-table">Creating a Single Table</h3>

<p>Finally, it is possible to put all of the data into a single table assuming that you avoid type conflicts. This is achieved by using the group() function with no arguments. Basically making the group key empty, so all of the data gets grouped into a single table.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="aggregations">Aggregations</h2>

<p>In the Flux vernacular, an “aggregation” is a summary of a table. Indeed, one of the key reasons to regroup is in order to summarize as desired.</p>

<p>As an example, to answer the question “do the different station types have different average windows speeds?” the overall approach would be to:</p>

<ol>
  <li>Query the time range of interest</li>
  <li>Filter to just the wind_speed_mps field</li>
  <li>Group the results into one table for each station type</li>
  <li>Calculate the mean for each table</li>
  <li>Put all the results into a single table</li>
</ol>

<p>The Flux looks like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_station_type
   </td>
   <td>_value
   </td>
  </tr>
  <tr>
   <td>2021-08-05T01:28:12.024108193Z
   </td>
   <td>2021-08-05T13:28:12.024108193Z
   </td>
   <td>buoy
   </td>
   <td>4.997794117647059
   </td>
  </tr>
  <tr>
   <td>2021-08-05T01:28:12.024108193Z
   </td>
   <td>2021-08-05T13:28:12.024108193Z
   </td>
   <td>fixed
   </td>
   <td>3.1083950617283946
   </td>
  </tr>
  <tr>
   <td>2021-08-05T01:28:12.024108193Z
   </td>
   <td>2021-08-05T13:28:12.024108193Z
   </td>
   <td>oilrig
   </td>
   <td>6.883999999999998
   </td>
  </tr>
  <tr>
   <td>2021-08-05T01:28:12.024108193Z
   </td>
   <td>2021-08-05T13:28:12.024108193Z
   </td>
   <td>other
   </td>
   <td>5.675675675675675
   </td>
  </tr>
</table>

<p>That last step of collapsing all the data for each table into a mean is what Flux calls “aggregation.”</p>

<p>The following sections cover some of the most common Flux aggregations.</p>

<h3 id="mean">mean()</h3>

<p>This function is typically used as demonstrated above:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">()</span>
</code></pre></div></div>

<p>When called without arguments, <code class="language-plaintext highlighter-rouge">mean()</code> function will use the _value column. However, it is possible that pivoted data will have more than one column that could be aggregated, and, additionally, it is possible to have renamed _value. In such cases, as demonstrated here:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="nx">rename</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">{</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">wind_speed</span><span class="dl">"</span><span class="p">})</span>
  <span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
<span class="nx">runtime</span> <span class="nx">error</span> <span class="p">@</span><span class="nd">7</span><span class="p">:</span><span class="mi">6</span><span class="o">-</span><span class="mi">7</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span> <span class="nx">mean</span><span class="p">:</span> <span class="nx">column</span> <span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span> <span class="nx">does</span> <span class="nx">not</span> <span class="nx">exist</span>
</code></pre></div></div>

<p>This can be fixed easily by specifying the column in the <code class="language-plaintext highlighter-rouge">mean()</code> function:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="nx">rename</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">{</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">wind_speed</span><span class="dl">"</span><span class="p">})</span>
  <span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">(</span><span class="nx">column</span><span class="p">:</span> <span class="dl">"</span><span class="s2">wind_speed</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_station_type
   </td>
   <td>wind_speed
   </td>
  </tr>
  <tr>
   <td>2021-08-05T01:28:12.024108193Z
   </td>
   <td>2021-08-05T13:28:12.024108193Z
   </td>
   <td>buoy
   </td>
   <td>4.997794117647059
   </td>
  </tr>
  <tr>
   <td>2021-08-05T01:28:12.024108193Z
   </td>
   <td>2021-08-05T13:28:12.024108193Z
   </td>
   <td>fixed
   </td>
   <td>3.1083950617283946
   </td>
  </tr>
  <tr>
   <td>2021-08-05T01:28:12.024108193Z
   </td>
   <td>2021-08-05T13:28:12.024108193Z
   </td>
   <td>oilrig
   </td>
   <td>6.883999999999998
   </td>
  </tr>
  <tr>
   <td>2021-08-05T01:28:12.024108193Z
   </td>
   <td>2021-08-05T13:28:12.024108193Z
   </td>
   <td>other
   </td>
   <td>5.675675675675675
   </td>
  </tr>
</table>

<p>Note that because <code class="language-plaintext highlighter-rouge">mean()</code> aggregates data from all rows in a table, most columns get dropped. Only the columns in the group key and the column that was subject to the <code class="language-plaintext highlighter-rouge">mean() </code> function is preserved.</p>

<h3 id="min-and-max">min() and max()</h3>

<p>These will always return exactly one row, with the lowest or highest value in the _value column for each table. Like with the <code class="language-plaintext highlighter-rouge">mean()</code> funciton, you can specify the column you want to use, but the _value column is used by default.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">keep</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="nx">min</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>_field
   </td>
   <td>_masurement
   </td>
   <td>_station_id
   </td>
   <td>_station_name
   </td>
   <td>station_owner
   </td>
   <td>station_pgm
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-05T02:27:53.856929358Z
   </td>
   <td>2021-08-05T14:27:53.856929358Z
   </td>
   <td>2021-08-05T05:00:00Z
   </td>
   <td>1
   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>45152
   </td>
   <td>Lake Nipissing
   </td>
   <td>Environment and Climate Change Canada
   </td>
   <td>,International Partners
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-05T02:27:53.856929358Z
   </td>
   <td>2021-08-05T14:27:53.856929358Z
   </td>
   <td>2021-08-05T04:30:00Z
   </td>
   <td>0
   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>ANMN6
   </td>
   <td>Field Station, Hudson River Reserve, NY
   </td>
   <td>National Estuarine Research Reserve System
   </td>
   <td>NERRS
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-05T02:27:53.856929358Z
   </td>
   <td>2021-08-05T14:27:53.856929358Z
   </td>
   <td>2021-08-05T05:30:00Z
   </td>
   <td>0
   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>KGRY
   </td>
   <td>Green Canyon 338 / Front Runner
   </td>
   <td>Federal Aviation Administration
   </td>
   <td>Marine METAR
   </td>
   <td>oilrig
   </td>
  </tr>
  <tr>
   <td>2021-08-05T02:27:53.856929358Z
   </td>
   <td>2021-08-05T14:27:53.856929358Z
   </td>
   <td>2021-08-05T05:30:00Z
   </td>
   <td>0
   </td>
   <td>wind_speed_mps
   </td>
   <td>ndbc
   </td>
   <td>46025
   </td>
   <td>,"Santa Monica Basin - 33NM WSW of Santa Monica, CA"
   </td>
   <td>NDBC
   </td>
   <td>NDBC Meteorological/Ocean
   </td>
   <td>other
   </td>
  </tr>
</table>

<p>In this case, all of the columns are retained. This is because <code class="language-plaintext highlighter-rouge">min()</code> and <code class="language-plaintext highlighter-rouge">max()</code> return a row per table. Effectively picking a row and filtering out the rest. These functions do not, therefore, need to combine values from different rows, so all of the columns are retained. Note that this can cause <code class="language-plaintext highlighter-rouge">group()</code> to fail if there are type conflicts in columns, as covered later in the section on type conflicts.</p>

<p>Of course, the data can be cleaned up by dropping unwanted columns:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="nx">min</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="nx">keep</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_time
   </td>
   <td>_value
   </td>
   <td>station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-05T05:00:00Z
   </td>
   <td>1
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-05T04:30:00Z
   </td>
   <td>0
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-05T05:30:00Z
   </td>
   <td>0
   </td>
   <td>oilrig
   </td>
  </tr>
  <tr>
   <td>2021-08-05T05:30:00Z
   </td>
   <td>0
   </td>
   <td>other
   </td>
  </tr>
</table>

<h3 id="count">count()</h3>

<p>The <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/count/">count()</a> function<code class="language-plaintext highlighter-rouge"> </code>returns the number of rows in a table. This can be particularly useful for counting events. In this case, it is used to count the number of the different station types reporting in:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="nx">count</span><span class="p">()</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
</code></pre></div></div>

<table>
  <tr>
   <td>_start
   </td>
   <td>_stop
   </td>
   <td>_value
   </td>
   <td>_station_type
   </td>
  </tr>
  <tr>
   <td>2021-08-05T04:00:59.334352876Z
   </td>
   <td>2021-08-05T16:00:59.334352876Z
   </td>
   <td>107
   </td>
   <td>buoy
   </td>
  </tr>
  <tr>
   <td>2021-08-05T04:00:59.334352876Z
   </td>
   <td>2021-08-05T16:00:59.334352876Z
   </td>
   <td>395
   </td>
   <td>fixed
   </td>
  </tr>
  <tr>
   <td>2021-08-05T04:00:59.334352876Z
   </td>
   <td>2021-08-05T16:00:59.334352876Z
   </td>
   <td>25
   </td>
   <td>oilrig
   </td>
  </tr>
  <tr>
   <td>2021-08-05T04:00:59.334352876Z
   </td>
   <td>2021-08-05T16:00:59.334352876Z
   </td>
   <td>73
   </td>
   <td>other
   </td>
  </tr>
</table>

<p>As in the case of <code class="language-plaintext highlighter-rouge">mean()</code>, because <code class="language-plaintext highlighter-rouge">count()</code> combines values from different columns, only columns in the group key and the _value column are retained.</p>

<p>As expected, for cases where the _value column does not exist in the tables to be counted, you can specify a different column to count:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">noaa</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="nx">h</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ndbc</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">wind_speed_mps</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">station_type</span><span class="dl">"</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="nx">rename</span><span class="p">(</span><span class="nx">columns</span><span class="p">:</span> <span class="p">{</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">windspeed</span><span class="dl">"</span><span class="p">})</span>
  <span class="o">|&gt;</span> <span class="nx">count</span><span class="p">(</span><span class="nx">column</span><span class="p">:</span> <span class="dl">"</span><span class="s2">windspeed</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">group</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="aggregates-and-selectors">Aggregates and Selectors</h3>
<p>While all transformations that summarize your data typically refered to as “aggregations” in Flux vernacular there are actually two types of aggregates:</p>
<ol>
  <li><a href="https://docs.influxdata.com/flux/v0.x/function-types/#aggregates">Aggregates</a>: These functions return a single row output for every input table. The output also has the same group key as the input table(s)–the <code class="language-plaintext highlighter-rouge">_time</code> column is usually dropped. Aggregates include but are not limited to the following functions:
    <ul>
      <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/count/">count()</a></li>
      <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/mean/">mean()</a></li>
      <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/mode/">mode()</a></li>
      <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/median/">median()</a></li>
      <li><a href="https://docs.influxdata.com/flux/v0.x/function-types/#aggregates">and more…</a></li>
    </ul>
  </li>
  <li><a href="https://docs.influxdata.com/flux/v0.x/function-types/#selectors">Selectors</a>: These functions return a one ore more rows for every input table. The output is an unmodified record–the <code class="language-plaintext highlighter-rouge">_time</code> column is typically included. Aggregates include but are not limited to the following functions:
    <ul>
      <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/min/">min()</a></li>
      <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/max/">max()</a></li>
      <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/distinct/">distinct()</a></li>
      <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/first/">first()</a></li>
      <li><a href="https://docs.influxdata.com/flux/v0.x/function-types/#selectors">and more…</a></li>
    </ul>
  </li>
</ol>

<h2 id="yielding">Yielding</h2>

<p>The <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/outputs/yield/">yield()</a> function determines which table inputs should be returned in a flux script. The yield() function also assigns a name to the output of a Flux query.  The name is stored in the default annotation.</p>

<p>For example if we query the following table:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>Measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>2021-09-17T21:22:52.00Z
   </td>
  </tr>
</table>

<p>Without the yield function:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T21</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mf">52.00</span><span class="nx">Z</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="p">)</span>
</code></pre></div></div>

<p>The following Annotated CSV output is returned. Notice the default annotation is set to <code class="language-plaintext highlighter-rouge">_results</code> by default.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,long,string,string,string
#default,_results,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,0,2021-08-17T21:22:52.452072242Z,2021-08-17T21:23:52.452072242Z,2021-08-17T21:23:39.010094213Z,1,field1,Measurement1,tagvalue1
</code></pre></div></div>

<p>Now if we add the yield() function:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">2021</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">17</span><span class="nx">T21</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mf">52.452072242</span><span class="nx">Z</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">myFluxQuery</span><span class="dl">"</span><span class="p">)</span> 
</code></pre></div></div>

<p>The following Annotated CSV output is returned. Notice the default annotation has been changed to <code class="language-plaintext highlighter-rouge">myFluxQuery</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,long,string,string,string
#default,myFluxQuery,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,0,2021-08-17T21:22:52.452072242Z,2021-08-17T21:23:52.452072242Z,2021-08-17T21:23:39.010094213Z,1,field1,Measurement1,tagvalue1
</code></pre></div></div>

<p>The yield() function is important because invoking multiple yield() functions allows you to return multiple table streams from a single Flux script simultaneously.</p>

<h3 id="returning-multiple-aggregations-with-multiple-yield-functions">Returning multiple aggregations with multiple yield() functions</h3>

<p>Imagine that you want to return the min(), max(), and mean() values of a single table:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>4.0
   </td>
   <td>rfc3339time3
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>5.0
   </td>
   <td>rfc3339time4
   </td>
  </tr>
</table>

<p>We’ll use this  meta syntactic example a lot. If you want to try following the solutions out for yourself, include the following Flux at the top of your script to produce the table above: <br />
<code class="language-plaintext highlighter-rouge">import "array"</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">experimental</span><span class="dl">"</span>

<span class="nx">rfc3339time1</span> <span class="o">=</span> <span class="nx">experimental</span><span class="p">.</span><span class="nx">subDuration</span><span class="p">(</span><span class="nx">d</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">m</span><span class="p">,</span> <span class="k">from</span><span class="p">:</span> <span class="nx">now</span><span class="p">())</span>
<span class="nx">rfc3339time2</span> <span class="o">=</span> <span class="nx">experimental</span><span class="p">.</span><span class="nx">subDuration</span><span class="p">(</span><span class="nx">d</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="nx">m</span><span class="p">,</span> <span class="k">from</span><span class="p">:</span> <span class="nx">now</span><span class="p">())</span>
<span class="nx">rfc3339time3</span> <span class="o">=</span> <span class="nx">experimental</span><span class="p">.</span><span class="nx">subDuration</span><span class="p">(</span><span class="nx">d</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="nx">m</span><span class="p">,</span> <span class="k">from</span><span class="p">:</span> <span class="nx">now</span><span class="p">())</span>
<span class="nx">rfc3339time4</span> <span class="o">=</span> <span class="nx">experimental</span><span class="p">.</span><span class="nx">subDuration</span><span class="p">(</span><span class="nx">d</span><span class="p">:</span> <span class="o">-</span><span class="mi">4</span><span class="nx">m</span><span class="p">,</span> <span class="k">from</span><span class="p">:</span> <span class="nx">now</span><span class="p">())</span>

<span class="nx">data</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">rows</span><span class="p">:</span> <span class="p">[</span>
<span class="p">{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time1</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">},</span>
<span class="p">{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time2</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">},</span>
<span class="p">{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time3</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">},</span>
<span class="p">{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time4</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">}])</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">metasyntaticExample</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>New Flux users, especially those from a SQL or InfluxQL background have the inclination to run the following Flux query:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">min</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="nx">max</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">()</span>
</code></pre></div></div>

<p>This is because they’re accustomed to being able to perform <code class="language-plaintext highlighter-rouge">SELECT min("field1"), max("field1"), mean("field1").</code> However, the Flux query above would actually just return the min value. Flux is pipe forwarded, so you must use multiple yield() functions to return the min, max, and mean together:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">min</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">min</span><span class="dl">"</span><span class="p">)</span> 

<span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">max</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">max</span><span class="dl">"</span><span class="p">)</span> 

<span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">mean</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>The above script would result in three tables:</p>

<p>Result: min</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
</table>

<p>Result: max</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>5.0
   </td>
   <td>rfc339time4
   </td>
  </tr>
</table>

<p>Result: mean</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>3.0
   </td>
  </tr>
</table>

<p><strong>An Aside:</strong> Remember that the mean() function doesn’t return a timestamp column because it’s an aggregator. There isn’t a timestamp associated with the mean value.</p>

<h3 id="using-variables-to-perform-multiple-aggregations">Using variables to perform multiple aggregations</h3>

<p>While the Flux query above will yield all three transformations, it’s not an efficient query because you’re querying for the entire dataset multiple times. Instead store the base query in a variable and reference it like so:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">tag1</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="p">)</span>

<span class="nx">data_min</span> <span class="o">=</span> <span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">min</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">min</span><span class="dl">"</span><span class="p">)</span> 

<span class="nx">data_max</span> <span class="o">=</span> <span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">max</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">max</span><span class="dl">"</span><span class="p">)</span> 

<span class="nx">data_mean</span> <span class="o">=</span> <span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">mean</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Important Note:</strong> Make sure not to name your variables the same as function names to avoid naming conflicts.</p>

<h2 id="pivoting">Pivoting</h2>

<p>The <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/pivot/">pivot()</a> function rotates column values into rows in a table. The most common use case for pivoting() data is for when users want to perform math across fields at the same timestamp.</p>

<p>The pivot() function has 3 input parameters:</p>

<ol>
  <li>rowKey: the list of columns that determines the row output</li>
  <li>columnKey: the list of columns that determines the column output</li>
  <li>valueColumn: the column from which the column values populate the cells of the pivoted table</li>
</ol>

<p>Given the following input data:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>3.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>4.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>We perform the following pivot:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
 <span class="o">|&gt;</span> <span class="nx">pivot</span><span class="p">(</span><span class="nx">rowKey</span><span class="p">:[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">],</span> <span class="nx">columnKey</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">],</span> <span class="nx">valueColumn</span><span class="p">:</span> <span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>field2
   </td>
   <td>field1
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>3.0
   </td>
   <td>1.0
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>4.0
   </td>
   <td>2.0
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Oftentimes users also want to pivot() on tags to compare a single field across multiple tags. For instance if a user wanted to calculate the difference between the last temperature value across two sensors from the Air Sensor sample dataset, they could uses the following query:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">co</span><span class="dl">"</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0100</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0101</span><span class="dl">"</span><span class="p">)</span>
<span class="c1">// the limit function is used to return the first two records in each table stream</span>
<span class="o">|&gt;</span> <span class="nx">limit</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span><span class="mi">2</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">before pivot</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">pivot</span><span class="p">(</span><span class="nx">rowKey</span><span class="p">:[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">],</span> <span class="nx">columnKey</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">],</span> <span class="nx">valueColumn</span><span class="p">:</span> <span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">after pivot</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Where the first yield returns the “before pivot” result:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.4901148636678805
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.4850389571399865
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.48242588117742446
   </td>
   <td>TLM0101
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.47503934770988365
   </td>
   <td>TLM0101
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Where the second yield() returns the “after pivot” result:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>TLM0101
   </td>
   <td>TLM0100
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.48242588117742446
   </td>
   <td>0.4901148636678805
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.47503934770988365
   </td>
   <td>0.4850389571399865
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>You can also pivot on multiple columns. This allows you to include values across fields and tags within the same record in a table. Let’s take the previous example but this time we filter for two fields instead of one and pivot on both the sensor_id and field:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">co</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">temperature</span><span class="dl">"</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0100</span><span class="dl">"</span> <span class="nx">or</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0101</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">before pivot on two fields and sensors</span><span class="dl">"</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">pivot</span><span class="p">(</span><span class="nx">rowKey</span><span class="p">:[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">],</span> <span class="nx">columnKey</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">],</span> <span class="nx">valueColumn</span><span class="p">:</span> <span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">after pivot before pivot on two fields and sensors</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Where the first yield returns the “before pivot on two fields and sensors” result:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.4901148636678805
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.4850389571399865
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.48242588117742446
   </td>
   <td>TLM0101
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.47503934770988365
   </td>
   <td>TLM0101
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>airSensors
   </td>
   <td>temperature
   </td>
   <td>71.21039164125095
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>airSensors
   </td>
   <td>temperature
   </td>
   <td>71.24535411172452
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>airSensors
   </td>
   <td>temperature
   </td>
   <td>71.83744572272158
   </td>
   <td>TLM0101
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>airSensors
   </td>
   <td>temperature
   </td>
   <td>71.85395748942119
   </td>
   <td>TLM0101
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Where the second yield() returns the “after pivot before pivot on two fields and sensors” result:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>TLM0100_co
   </td>
   <td>TLM0101_co
   </td>
   <td>TLM0100_temperature
   </td>
   <td>TLM0101_temperature
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>0.4901148636678805
   </td>
   <td>0.48242588117742446
   </td>
   <td>71.21039164125095
   </td>
   <td>71.83744572272158
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>0.4850389571399865
   </td>
   <td>0.47503934770988365
   </td>
   <td>71.24535411172452
   </td>
   <td>71.85395748942119
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h3 id="the-fieldsascol-function">The fieldsAsCol() function</h3>

<p>Pivoting fields on the timestamp column, as described in the first pivoting example, is the most common type of pivoting. Users frequently expect that their data be presented in that way, where the column name contains the field key and the field values are in that column. This application of the pivot() function is so commonly used that the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/influxdata/influxdb/schema/fieldsascols/">schema.fieldsAsCols()</a> function was created. This function works identically to:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">pivot</span><span class="p">(</span><span class="nx">rowKey</span><span class="p">:[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">],</span> <span class="nx">columnKey</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">],</span> <span class="nx">valueColumn</span><span class="p">:</span> <span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="mapping">Mapping</h2>

<p>The <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/map/">map()</a> function is an extremely powerful tool. It applies a function to each record in the table. Use the map() function to:</p>

<ul>
  <li>Perform a transformation on values in a column and replace the original values transformation.</li>
  <li>Add new columns to store the transformations or new data.</li>
  <li>Conditionally transform records with conditional query logic within the map function.</li>
  <li>Change the types of values in a column.</li>
</ul>

<p>For this section we’ll use the map() function to transform the following data from the Air Sensor sample dataset:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">co</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0100</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">map</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.4901148636678805
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.4850389571399865
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h3 id="in-place-transformation">In place transformation</h3>

<p>The map() function requires a single input parameter:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fn</code>: The function to apply to each record in the table stream.</li>
</ul>

<p>To perform an in-column transformation make sure to reuse a column name in the function. For example, imagine that our TM0100 sensor is faulty and consistently off by 0.02 ppm. We can add 0.02 to every record in the _value column in our data with the map function: <br />
<code class="language-plaintext highlighter-rouge">data</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="nx">r</span><span class="p">.</span><span class="na">_value</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">+</span> <span class="mf">0.02</span><span class="p">}))</span>
</code></pre></div></div>

<p>Which yields the following result: \</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.5101148636678805
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.5050389571399865
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>In other words, the<code class="language-plaintext highlighter-rouge"> with</code> operator updates a column if that column already exists.</p>

<h3 id="new-columns">New column(s)</h3>

<p>You can use the map function to add new columns to your data. For example we could perform the following column to add a new column with the adjustment value and then calculate the true value with the map() function:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">adjustment</span><span class="p">:</span> <span class="mf">0.02</span> <span class="p">,</span> <span class="na">trueValue</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">+</span> <span class="nx">r</span><span class="p">.</span><span class="nx">adjustment</span><span class="p">}))</span> 
</code></pre></div></div>

<p>Which yields the following result:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>adjustment
   </td>
   <td>_value
   </td>
   <td>trueValue
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.02
   </td>
   <td>0.5101148636678805
   </td>
   <td>0.5101148636678805
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.02
   </td>
   <td>0.5050389571399865
   </td>
   <td>0.5050389571399865
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>In other words, the<code class="language-plaintext highlighter-rouge"> with</code> operator creates a new column if one doesn’t already exist. You can also add new columns with the map() function without the<code class="language-plaintext highlighter-rouge"> with</code> operator. However, when you use the map() function in this way you drop all of the columns that aren’t explicitly mapped. For example, the following query:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">adjustment</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span> <span class="na">_time</span><span class="p">:</span><span class="nx">r</span><span class="p">.</span><span class="nx">_time</span><span class="p">}))</span> 
</code></pre></div></div>

<p>Yields the following result:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>adjustment
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>0.02
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>0.02
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p><strong>Note:</strong> You can also use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/set/">set()</a> function to create a new column with a string value.</p>

<h3 id="conditionally-transform-data">Conditionally transform data</h3>

<p>Conditionally transforming data with the map() function is an especially useful feature. This combination unlocks another level of sophisticated transformation work. A common use for conditional mapping is to assign conditions or state to numeric values. This is especially common for users who want to create custom checks. Suppose that any co value greater than 0.49 is concerning and and value below that is normal, then we can write the following query to summarize that behaviour in a new tag or column with conditional mapping: 
<code class="language-plaintext highlighter-rouge">data</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="nx">r</span> <span class="kd">with</span> <span class="na">level</span><span class="p">:</span>
      <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&gt;=</span> <span class="mf">0.49</span> <span class="nx">then</span> <span class="dl">"</span><span class="s2">warn</span><span class="dl">"</span>
      <span class="k">else</span> <span class="dl">"</span><span class="s2">normal</span><span class="dl">"</span>
    <span class="p">})</span>
  <span class="p">)</span>
</code></pre></div></div>

<p>The query above yields the following result:</p>

<table>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>level
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.4901148636678805
   </td>
   <td>warning
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.4850389571399865
   </td>
   <td>normal
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h3 id="changing-types">Changing types</h3>

<p>Changing data types is useful for a variety of situations including:</p>

<ul>
  <li>Performing math across fields with different data types with the map() function</li>
  <li>To address some of the challenges around grouping data with different datatypes</li>
  <li>Preparing data for further transformation work both with Flux and outside of InfluxDB</li>
</ul>

<p>If we wanted to change the our data from a float to an integer we would perform the following query:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> 
<span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">_value</span><span class="p">:</span> <span class="nx">int</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span><span class="p">)}))</span> 
</code></pre></div></div>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p><strong>Note:</strong> you can also use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/tofloat/">toFloat()</a>, <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/toint/">toInt()</a>, and <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/tostring/">toString()</a> function to convert values in the _value column to a float, integer, and string respectively. However, the map() function allows you to convert any column you like. You might also want to use the map() function to conditionally convert types when querying for multiple fields.</p>

<h3 id="the-rowsmap-function">The rows.map() function</h3>

<p>The <a href="https://docs.influxdata.com/flux/v0.x/stdlib/contrib/jsternberg/rows/map/">rows.map()</a> function is a simplified version of the map() function. It is much more efficient but also more limited than the map() function. Remember the map() function can modify group keys. However, the rows.map() function cannot. Attempts to modify columns in the group key are ignored. For example, if we tried to change the measurement name with the rows.map() function it would be unsuccessful. However we could adjust the field value like beofre:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">rows</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="nx">r</span> <span class="kd">with</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">in group key so it's ignored</span><span class="dl">"</span><span class="p">}))</span>
<span class="o">|&gt;</span> <span class="nx">rows</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="nx">r</span><span class="p">.</span><span class="na">_value</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">+</span> <span class="mf">0.02</span><span class="p">}))</span>
</code></pre></div></div>

<p>Which yields the following result:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not in Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.5101148636678805
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>airSensors
   </td>
   <td>co
   </td>
   <td>0.5050389571399865
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h2 id="returning-values-and-arrays">Returning values and arrays</h2>

<p>Sometimes users need to be able to query their data, obtain a value or array of values, and then incorporate those values in subsequent transformation work. The <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/stream-table/findrecord/">fromRecord()</a> and <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/stream-table/findcolumn/">fromColumns()</a> functions allow you to return individual records and columns, respectively.</p>

<h3 id="returning-records">Returning records</h3>

<p>The <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/findrecord/">findRecord()</a> function requires two input parameters:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fn</code>: The predicate function for returning the table with matching keys, provided by the user.</li>
  <li><code class="language-plaintext highlighter-rouge">idx</code>: The index of the record you want to extract.</li>
</ul>

<p>The easiest way to use the fromRecord() function is to query our data so that you have only one row in your output that contains the scalar value you want to extract. This way you can just set the fn parameter to true idx to 0.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">buket</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
	<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
	<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">=</span>  <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">meanRecord</span> <span class="o">=</span> <span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">()</span> 
<span class="o">|&gt;</span> <span class="nx">findRecord</span><span class="p">(</span> <span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
      		<span class="nx">idx</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="nx">data</span> <span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">value_mult_by_mean</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">*</span> <span class="nx">meanRecord</span><span class="p">.</span><span class="nx">_value</span> <span class="p">}))</span>
     <span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">final result</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Given that the first yield() function returns “data”:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rfc339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rfc339time2
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>4.0
   </td>
   <td>rfc339time3
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>5.0
   </td>
   <td>rfc339time4
   </td>
  </tr>
</table>

<p>Then <code class="language-plaintext highlighter-rouge">meanRecord._value = 4.0. </code>Therefore the second yield() function returns “final result”:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>value_mult_by_mean
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>4.0
   </td>
   <td>rfc339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>8.0
   </td>
   <td>rfc339time2
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>4.0
   </td>
   <td>16.0
   </td>
   <td>rfc339time3
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>5.0
   </td>
   <td>20.0
   </td>
   <td>rfc339time4
   </td>
  </tr>
</table>

<p>To illustrate how to use fromRecord() let’s use the Air Sensor sample dataset to calculate the water vapour pressure from one sensor with the mean temperature. The equation for the water vapour pressure is:</p>

<p>water vapour pressure = humidity * ( gas constant * temperature/ molecular weight of water).</p>

<p>For this example, we’ll incorporate the following hypothetical assumption: we want to use the mean temperature instead of the actual temperature because our temperature sensors are faulty. Let’s also assume that the temperature and humidity values are in the correct units for simplicity.</p>

<p>Therefore, we can calculate the water vapour pressure with the following Flux:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0100</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">limit</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span> 

<span class="nx">meanRecord</span> <span class="o">=</span> <span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">temperature</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">raw temperature</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">mean</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="nx">findRecord</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">idx</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">humidity</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span>  <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">mean_record</span><span class="p">:</span> <span class="nx">meanRecord</span><span class="p">.</span><span class="nx">_value</span><span class="p">}))</span>
<span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">water_vapor_pressure</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">*</span> <span class="p">(</span><span class="mf">8.31</span> <span class="o">*</span> <span class="nx">meanRecord</span><span class="p">.</span><span class="nx">_value</span> <span class="o">/</span> <span class="mf">18.02</span><span class="p">)}))</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">final result</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Where the output of the first yield() function returns the “raw temperature”:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.18548279203421
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.22676508109254
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.27370100659799
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time3
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.28825526616907
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time4
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.25024765248021
   </td>
   <td>TLM0100
   </td>
   <td>rfc3339time5
   </td>
  </tr>
</table>

<p>And the output of the second yield() function returns the “final result”:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field 
   </td>
   <td>_value
   </td>
   <td>sensor_id
   </td>
   <td>mean_record
   </td>
   <td>water_vapor_pressure
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.18548279203421
   </td>
   <td>TLM0100
   </td>
   <td>71.2448903596748
   </td>
   <td>1153.9546087866322
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.22676508109254
   </td>
   <td>TLM0100
   </td>
   <td>71.2448903596748
   </td>
   <td>1153.9546087866322
   </td>
   <td>rfc3339time2
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.27370100659799
   </td>
   <td>TLM0100
   </td>
   <td>71.2448903596748
   </td>
   <td>1153.9546087866322
   </td>
   <td>rfc3339time3
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.28825526616907
   </td>
   <td>TLM0100
   </td>
   <td>71.2448903596748
   </td>
   <td>1153.9546087866322
   </td>
   <td>rfc3339time4
   </td>
  </tr>
  <tr>
   <td>airSensor
   </td>
   <td>temperature
   </td>
   <td>71.25024765248021
   </td>
   <td>TLM0100
   </td>
   <td>71.2448903596748
   </td>
   <td>1153.9546087866322
   </td>
   <td>rfc3339time5
   </td>
  </tr>
</table>

<p>Another common use for the findRecord() function is extracting a timestamp at the time of an event  (or when some of your data meets a certain condition) and then using that timestamp to query for other data at the time of the event. For example, we can query for humidity from one sensor in the Air Sensor sample dataset after the first time the temperature exceeded 72.2 degrees.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0101</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">tempTime</span> <span class="o">=</span> <span class="nx">data</span> 
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">temperature</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">72.2</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">findRecord</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">idx</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="nx">data</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="nx">tempTime</span><span class="p">.</span><span class="nx">_time</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">humidity</span><span class="dl">"</span><span class="p">)</span> 
</code></pre></div></div>

<p>This example brings up two other interesting points about the range() and filter() function:</p>

<ol>
  <li>You can use the range() function multiple times within the same query to further reduce the output of your query.</li>
  <li>You can also further limit the response to within a specific time range with the filter() function instead of using range twice. In other words we could have replaced the last three lines with:</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> 
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">tempTime</span><span class="p">.</span><span class="nx">_time</span><span class="p">)</span> 
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">humidity</span><span class="dl">"</span><span class="p">)</span> 
</code></pre></div></div>

<h3 id="returning-columns">Returning columns</h3>

<p>You can also return entire arrays that contain the values from a single column with Flux with the <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/stream-table/findcolumn/">findColumn()</a> function. The findColumn() function is similar to the findRecord() function and requires the following two input parameters:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fn</code>: The predicate function for returning the table with matching keys, provided by the user.</li>
  <li><code class="language-plaintext highlighter-rouge">column</code>: The column of the records you want to extract in an array.</li>
</ul>

<p>Let’s replace the findRecord() function from the last example in the previous section, <a href="/docs/part-2/querying-and-data-transformations/#returning-records">Returning records</a>, with findColumn().</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0101</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">tempTime</span> <span class="o">=</span> <span class="nx">data</span> 
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">temperature</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">72.2</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">findRecord</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">column</span><span class="p">:</span> <span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">data</span> 
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="nx">tempTime</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">humidity</span><span class="dl">"</span><span class="p">)</span> 
</code></pre></div></div>

<h2 id="reducing">Reducing</h2>

<p>The <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/aggregates/reduce/">reduce()</a> function is used to perform custom aggregations. The reduce() function takes two parameters:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">fn</code>: the reducer function, where you define the function that you want to apply to each record in the table with the identity.</li>
  <li><code class="language-plaintext highlighter-rouge">identity</code>: where you define the initial values when creating a reducer function.</li>
</ol>

<p>For this section we’ll use the following data:</p>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rcc3339time1
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rcc3339time2
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>4.0
   </td>
   <td>rcc3339time3
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>5.0
   </td>
   <td>rcc3339time4
   </td>
  </tr>
</table>

<p>Here is a simple example of how to uses the reduce() function to calculate the sum of the values:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Measurement1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span> <span class="p">)</span>

<span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">reduce</span><span class="p">(</span>
        <span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">accumulator</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
          <span class="na">sum</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">+</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">sum</span>
        <span class="p">}),</span>
        <span class="nx">identity</span><span class="p">:</span> <span class="p">{</span><span class="nl">sum</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
    <span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">sum_reduce</span><span class="dl">"</span><span class="p">)</span> 
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">sum</code> identity is initialized at 0.0. The reducer function takes the <code class="language-plaintext highlighter-rouge">accumulator.sum</code> and adds it to the field value in each record.  The output of the reducer function is given back as the input into the <code class="language-plaintext highlighter-rouge">accumulator.sum. </code></p>

<p>The Flux above yields following result:<code class="language-plaintext highlighter-rouge"> \
</code></p>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>sum 
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>12.0
   </td>
  </tr>
</table>

<p>Only columns that are part of the group key are included in the output of the reduce() function.</p>

<p>To further understand the reduce() function, let’s calculate the min(), max(), and mean()  simultaneously with the reduce() function.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">reduce</span><span class="p">(</span>
      <span class="nx">identity</span><span class="p">:</span> <span class="p">{</span><span class="nl">count</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">sum</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">min</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">max</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">mean</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">},</span>
      <span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">accumulator</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
        <span class="na">count</span><span class="p">:</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="na">sum</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">+</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">sum</span><span class="p">,</span>
        <span class="na">min</span><span class="p">:</span> <span class="k">if</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="nx">then</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&lt;</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">min</span> <span class="nx">then</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="k">else</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span>
        <span class="na">max</span><span class="p">:</span> <span class="k">if</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="nx">then</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&gt;</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">max</span> <span class="nx">then</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="k">else</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">max</span><span class="p">,</span>
        <span class="na">mean</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">+</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">sum</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nx">accumulator</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
      <span class="p">})</span>
    <span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">min_max_mean_reduce</span><span class="dl">"</span><span class="p">)</span> 
</code></pre></div></div>

<p>The Flux above yields following result:</p>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>count
   </td>
   <td>sum
   </td>
   <td>min
   </td>
   <td>max
   </td>
   <td>mean
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>4.0
   </td>
   <td>12.0 
   </td>
   <td>1.0
   </td>
   <td>5.0
   </td>
   <td>3.0
   </td>
  </tr>
</table>

<p>Generally, the reduce() function isn’t more performant than built-in aggregators and selectors. Therefore, you shouldn’t use the query above to calculate the min, max, and mean. Instead, store your data in a variable and apply the min(), max(), and mean() functions separately with corresponding yield() functions to simultaneously deliver the results, as described previously in the <a href="/time-to-awesome/docs/part-2/querying-and-data-transformations/#yielding">Yielding section</a>.</p>

<p>The reducer() function is intended to be used to apply custom aggregations. For example, the following example uses the reducer() function to find the necessary variables used to calculate the slope and y-intercept for linear regression:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">|&gt;</span> <span class="nx">reduce</span><span class="p">(</span>
            <span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">accumulator</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
                <span class="na">sx</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">sx</span><span class="p">,</span>
                <span class="na">sy</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">sy</span><span class="p">,</span>
                <span class="na">N</span><span class="p">:</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">N</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="na">sxy</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">r</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">sxy</span><span class="p">,</span>
                <span class="na">sxx</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">r</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">accumulator</span><span class="p">.</span><span class="nx">sxx</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="nx">identity</span><span class="p">:</span> <span class="p">{</span>
                <span class="nl">sxy</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="nx">sx</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="nx">sy</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="nx">sxx</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="nx">N</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>
</code></pre></div></div>

<p>Where…</p>

<p><code class="language-plaintext highlighter-rouge">sx</code> is the sum of the index or independent variable.</p>

<p><code class="language-plaintext highlighter-rouge">sy</code> is the sum of the dependent variable.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`N` is the index.


`sxy` is the sum of the multiple of the independent and dependent variables.


`sxx` is the sum of the multiple of the independent variables. 
</code></pre></div></div>

<p><strong>Important Note: the reduce() function excludes any columns that aren’t in the group key in the output</strong>.</p>

<h2 id="manipulating-time">Manipulating Time</h2>

<p>Manipulating timestamps is critical for any time series analysis tool. Timestamp manipulation in Flux includes:</p>

<ul>
  <li>Converting timestamp formats</li>
  <li>Calculating durations</li>
  <li>Truncating or rounding timestamps</li>
  <li>Shifting times</li>
  <li>Other time manipulations</li>
</ul>

<h3 id="converting-timestamp-formants">Converting timestamp formants</h3>

<p>So far timestamps have been represented as the following formats:</p>

<ul>
  <li>Unix: <code class="language-plaintext highlighter-rouge">1567029600</code></li>
  <li>RFC3339: <code class="language-plaintext highlighter-rouge">2019-08-28T22:00:00Z</code></li>
  <li>Relative Duration: -<code class="language-plaintext highlighter-rouge">1h</code></li>
  <li>Duration: <code class="language-plaintext highlighter-rouge">1h</code></li>
</ul>

<p>The range() function accepts all of those timestamps formats. However, the Annotated CSV output of a Flux query returns the timestamp data in RFC3339 by default. Users need to return the data in another timestamp format to avoid parsing strings for application development on top of InfluxDB.</p>

<p>Convert your timestamp from RFC3339 to Unix by using the <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/type-conversions/uint/">uint()</a> or <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/type-conversions/int/">int()</a> function. Use the map() function to convert every record in your your _time column to a Unix timestamp.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
  <span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">_time</span><span class="p">:</span> <span class="nx">int</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_time</span><span class="p">)}))</span>
</code></pre></div></div>

<p>Or</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
  <span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">_time</span><span class="p">:</span> <span class="nx">uint</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_time</span><span class="p">)})</span>
</code></pre></div></div>

<p>Convert your timestamp from Unix to RFC3339 by using the <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/type-conversions/time/">time()</a> function.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
  <span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">_time</span><span class="p">:</span> <span class="nx">time</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_time</span><span class="p">)}))</span>
</code></pre></div></div>

<p>Using the Air Sensor sample dataset we can manipulate the _time column from RFC339 to Unix and back into RFC339 again, storing the results in separate columns:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span><span class="s2">`
  |&gt; filter(fn: (r) =&gt; r["_measurement"] == "airSensors")
  |&gt; filter(fn: (r) =&gt; r["_field"] == "co")
  |&gt; filter(fn: (r) =&gt; r["sensor_id"] == "TLM0100")
  |&gt; map(fn: (r) =&gt; ({ r with unix_time: int(v: r._time)}))
  |&gt; map(fn: (r) =&gt; ({ r with rfc3339_time: time(v: r._time)}))
</span></code></pre></div></div>

<p><strong>Important Note</strong>: the time() function requires that the unix timestamp must be in nanosecond precision.</p>

<h3 id="calculating-durations">Calculating durations</h3>

<p>Converting time from RFC3339 to Unix is especially useful when you want to find the duration between two points. To calculate the duration between two data points:</p>

<ol>
  <li>Convert the time to Unix timestamp</li>
  <li>Subtract the two Unix timestamps from each other</li>
  <li>Use the duration() function to convert the Unix time difference into a duration</li>
</ol>

<p>Let’s calculate the duration between the current time and a few points from the Air Sensor sample dataset:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">unix_now</span> <span class="o">=</span> <span class="nx">uint</span><span class="p">(</span><span class="nx">v</span><span class="p">:</span><span class="nx">now</span><span class="p">())</span>

<span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">co</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TLM0100</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">limit</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="nx">r</span> <span class="kd">with</span> <span class="na">duration_from_now</span><span class="p">:</span> <span class="nx">string</span><span class="p">(</span><span class="nx">duration</span><span class="p">(</span><span class="nx">unix_now</span> <span class="o">-</span> <span class="nx">uint</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_time</span><span class="p">)))}))</span>
</code></pre></div></div>

<p><strong>Important Note:</strong> Flux tables don’t support the duration time format. You must use the <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/type-conversions/string/">string()</a> function to convert the duration to a string.</p>

<p>It’s common for users who gather data from IoT devices at the edge to collect data for a while before pushing some of it to InfluxDB Cloud. They frequently want to include both the timestamp that the device recorded a metric and the timestamp when the data was actually written to InfluxDB Cloud. In this instance users should store the timestamp of the metric reading as a field as a string. Then they might want to find the duration between the time the sensor recorded the metric and the time the data was written to InfluxDB. Given the following data:</p>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group key
   </td>
  </tr>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
   <td>_device_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-09-10T07:15:12.000Z
   </td>
   <td>1631812512000
   </td>
  </tr>
</table>

<p>You can use a combination of int(), uint(), duration(), and string() functions to:</p>

<ul>
  <li>Convert the _device_time from a string to an integer</li>
  <li>Convert unix timestamp into nanosecond precision by multiplying by 10000</li>
  <li>Convert the rfc3339 timestamp of the _time column to a unix timestamp</li>
  <li>Calculate the duration and convert it to a string</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
  <span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">_device_time</span><span class="p">:</span> <span class="nx">int</span><span class="p">(</span><span class="na">v</span><span class="p">:</span><span class="nx">r</span><span class="p">.</span><span class="nx">_device_time</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="p">}))</span>
  <span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">r</span> <span class="kd">with</span> <span class="na">duration</span><span class="p">:</span> <span class="nx">string</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">duration</span><span class="p">(</span><span class="na">v</span><span class="p">:</span><span class="nx">uint</span><span class="p">(</span><span class="na">v</span><span class="p">:</span><span class="nx">r</span><span class="p">.</span><span class="nx">_device_time</span><span class="p">)</span> <span class="o">-</span> <span class="nx">uint</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_time</span><span class="p">)))}))</span>
</code></pre></div></div>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group key
   </td>
   <td>Not In Group key
   </td>
  </tr>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
   <td>_device_time
   </td>
   <td>duration
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-09-10T07:15:12.000Z
   </td>
   <td>1631812512000000000
   </td>
   <td>6d10h
   </td>
  </tr>
</table>

<h3 id="truncating-or-rounding-timestamps">Truncating or rounding timestamps</h3>

<p>Frequently users have data that’s irregular or recorded at different intervals. The most common reason for rounding timestamps is to either:</p>

<ol>
  <li>Transform an irregular time series into a regular one. An irregular time series is data that isn’t collected at a regular interval. Event data is an example of irregular time series.</li>
  <li>Align different time series collected at different intervals so that the user can perform subsequent data transformations on top of the aligned data.</li>
</ol>

<p>Given the following input data:</p>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-07-17T12:05:21
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>2021-07-17T12:05:24
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>4.0
   </td>
   <td>2021-07-17T12:05:27
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>5.0
   </td>
   <td>2021-07-17T12:05:28
   </td>
  </tr>
</table>

<p>Use the <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/truncatetimecolumn/">truncateTimeColumn()</a> function to to convert an irregular time series into a regular one: \</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> 
<span class="o">|&gt;</span> <span class="nx">truncateTimeColumn</span><span class="p">(</span><span class="nx">unit</span><span class="p">:</span> <span class="mi">5</span><span class="nx">s</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-07-17T12:05:20
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>2021-07-17T12:05:20
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>4.0
   </td>
   <td>2021-07-17T12:05:25
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>5.0
   </td>
   <td>2021-07-17T12:05:25
   </td>
  </tr>
</table>

<p>Truncating timestamps is similar to the section on</p>

<p id="gdcalert8"><span style="color: red; font-weight: bold">&gt;&gt;&gt;&gt;&gt;  gd2md-html alert: undefined internal link (link text: "Windowing"). Did you generate a TOC? </span><br />(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br /><span style="color: red; font-weight: bold">&gt;&gt;&gt;&gt;&gt; </span></p>

<p><a href="#heading=h.ro1q6m6reiml">Windowing</a>. The window() function groups data by start and stop times. This allows you to perform aggregations across different fields or tags that have different timestamps. Similarly you can aggregate across fields by truncating timestamps to align series with different intervals. Given the following data:</p>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-07-17T12:05:50
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>2021-07-17T12:05:20
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1 
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>4.0
   </td>
   <td>2021-07-17T12:05:27
   </td>
  </tr>
  <tr>
   <td>1
   </td>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>5.0
   </td>
   <td>2021-07-17T12:05:45
   </td>
  </tr>
</table>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> 
<span class="o">|&gt;</span> <span class="nx">truncateTimeColumn</span><span class="p">(</span><span class="nx">unit</span><span class="p">:</span> <span class="mi">30</span><span class="nx">s</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">group</span><span class="p">(</span><span class="nx">columns</span><span class="p">:[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">])</span>
<span class="o">|&gt;</span> <span class="nx">sum</span><span class="p">()</span> 
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>measurement1
   </td>
   <td>3.0
   </td>
   <td>2021-07-17T12:05:00
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>1 
   </td>
   <td>measurement1
   </td>
   <td>9.0
   </td>
   <td>2021-07-17T12:05:30
   </td>
  </tr>
</table>

<h3 id="shifting-time">Shifting time</h3>

<p>Users frequently need to shift their timestamps to convert their data to a different timezone. Given the following data:</p>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-07-17T08:00:00
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>2021-07-17T09:00:00
   </td>
  </tr>
</table>

<p>Use the <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/timeshift/">timeShift()</a> function to shift the data 2 hours ahead:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span> 
<span class="o">|&gt;</span> <span class="nx">timeShift</span><span class="p">(</span><span class="nx">duration</span><span class="p">:</span> <span class="mi">2</span><span class="nx">h</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>2021-07-17T10:00:00
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>2021-07-17T11:00:00
   </td>
  </tr>
</table>

<p><strong>Note:</strong> By default the timeShift() function shifts the timestamps in the _start, _stop, and _time columns.</p>

<h3 id="other-time-manipulations">Other time manipulations</h3>

<p>There are several other timestamp manipulation functions to be aware of in Flux. Although we won’t go into detail about how to use them all, it’s worth being aware of them:</p>

<ul>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/built-in/transformations/hourselection/">hourSelection()</a>: select data between specific parts of the day.</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/built-in/transformations/type-conversions/duration/">duration()</a>: convert a timestamp to a duration in terms of seconds, minutes, hours, etc.</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/contrib/events/duration/">events.Duration()</a>: calculate the duration between events</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/built-in/misc/now/">now()</a>: return the current time</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/system/time/">system.time()</a>: return the current time of the system</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/built-in/transformations/type-conversions/time/">time()</a>: convert a Unix nanosecond timestamp to an RFC3339 timestamp</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/built-in/transformations/type-conversions/uint/">uint()</a>: convert RFC3339 timestamp to a Unix nanosecond timestamp</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/built-in/transformations/truncatetimecolumn/">truncateTimeColumn()</a>: round or truncate an entire column to a specific timestamp unit</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/date/truncate/">date.truncate()</a>: round or truncate data down to a specific timestamp unit.</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/experimental/">Flux experimental package</a>. This package includes a wide variety of useful functions outside of time series transformations that might be useful to you:
    <ul>
      <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/experimental/addduration/">experimental.addDuration()</a>: add timestamps to each other</li>
      <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/experimental/subduration/">experimental.subDuration()</a>: subtract timestamps from each other</li>
      <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/experimental/aligntime/">experimental.alignTime()</a>: compare data across windows; i.e., week over week or month over month.</li>
    </ul>
  </li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/date/">Flux date package</a>: The Flux date package provides date and time constants and functions.</li>
</ul>

<h2 id="regex">Regex</h2>

<p><a href="https://docs.influxdata.com/influxdb/cloud/query-data/flux/regular-expressions/">Using regular expressions</a> or regex in Flux is a very powerful tool for filtering for data subsets by matching patterns. Regex is most commonly used in conjunction with functions like the filter(), map(), keep(), or drop() functions. Let’s use the Air Sensor sample dataset, to highlight how to use regex. Remember, we have the following tag and tag keys:</p>

<ul>
  <li>1 tag: sensor_id
    <ul>
      <li>8 sensor_id tag values:
        <ul>
          <li>TML0100</li>
          <li>TML0101</li>
          <li>TML0102</li>
          <li>TML0103</li>
          <li>TML0200</li>
          <li>TML0201</li>
          <li>TML0202</li>
          <li>TML0203</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>If we wanted to filter for all of sensors with in the 100 range, we could uses the following query:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">=~</span> <span class="sr">/TML0</span><span class="se">[</span><span class="sr">1</span><span class="se">][</span><span class="sr">0</span><span class="se">][</span><span class="sr">0-3</span><span class="se">]</span><span class="sr">$/</span><span class="p">)</span>
</code></pre></div></div>

<p>Flux uses <a href="https://pkg.go.dev/regexp/syntax">Go’s regexp package</a>. When constructing a regex it’s a good idea to use a regex tester to make sure that your regex is returning the correct data.  You can find a wide selection of regex testers online. I enjoy <a href="https://regex101.com/">regex101</a>. To increase the performance of your Flux query it’s a good idea to make your regex as specific as possible. For example, we could use the following query with bad regex instead:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">=~</span> <span class="sr">/10/</span><span class="p">)</span>
</code></pre></div></div>

<p>While it will work and only return data for the TML0100, TML0101, TML0102, and TML0103 sensors, it’s far less specific and efficient than our original regex. You can also use regex to filter for columns like so:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">TML0100</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">co</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">drop</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">column</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">column</span> <span class="o">!~</span> <span class="sr">/^_.*/</span><span class="p">)</span>
</code></pre></div></div>

<p>This query drops all columns that don’t start with an underscore. Since our dataset only has one tag, “sensor_id”, that’s the column that will be dropped.</p>

<h3 id="the-regexp-package">The Regexp Package</h3>

<p>Flux also has a <a href="https://docs.influxdata.com/flux/v0.x/stdlib/regexp/">regexp package</a>. This package has a variety of functions that make it easy to work with regex. You can store regex as strings in InfluxDB and use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/regexp/compile/">regexp.compile()</a> function to compile the strings into regex to filter for those strings. This is especially useful if you’re using a map() function with conditional mapping. Compiling a string into a regex outside of the map() is more efficient than compiling inside of the map(). In the example below we’re evaluating whether or not the URL field values are https or http URLS.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">url</span> <span class="o">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">compile</span><span class="p">(</span><span class="nx">v</span><span class="p">:</span> <span class="dl">"</span><span class="s2">^https</span><span class="dl">"</span> <span class="p">)</span>
<span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="nx">r</span> <span class="kd">with</span>
    <span class="na">isEncrypted</span><span class="p">:</span>
      <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">=~</span> <span class="nx">url</span> <span class="nx">then</span> <span class="dl">"</span><span class="s2">yes</span><span class="dl">"</span>
      <span class="k">else</span> <span class="dl">"</span><span class="s2">no</span><span class="dl">"</span>
    <span class="p">})</span>
  <span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>isEncrypted
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>measurement1
   </td>
   <td>URL
   </td>
   <td>https://foo
   </td>
   <td>yes
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>URL
   </td>
   <td>http://bar
   </td>
   <td>no
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h2 id="the-string-package">The String Package</h2>

<p>The <a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/strings/">Flux string package</a> has a large selection of functions that allow you to manipulate string values. With the Flux string package you can do things like:</p>

<ul>
  <li>Compare two strings to see if they match</li>
  <li>See if one string contains characters in another string or contains a specified substring</li>
  <li>Contains uppercase letters, lowercase letters, digits</li>
  <li>Replace, split, or join strings</li>
  <li>And much more</li>
</ul>

<p>For example we could replace the query in</p>

<p id="gdcalert9"><span style="color: red; font-weight: bold">&gt;&gt;&gt;&gt;&gt;  gd2md-html alert: undefined internal link (link text: "The Regexp Package"). Did you generate a TOC? </span><br />(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br /><span style="color: red; font-weight: bold">&gt;&gt;&gt;&gt;&gt; </span></p>

<p><a href="#heading=h.vcg0ziczwdot">The Regexp Package</a> section with:  \</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">strings</span><span class="dl">"</span>

<span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="nx">r</span> <span class="kd">with</span>
    <span class="na">isEncrypted</span><span class="p">:</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">containsStr</span><span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span><span class="p">,</span> <span class="na">substr</span><span class="p">:</span> <span class="dl">"</span><span class="s2">https</span><span class="dl">"</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">)</span>
</code></pre></div></div>

<p>Thereby returning a similar output:</p>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not in Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>isEncrypted
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>measurement1
   </td>
   <td>URL
   </td>
   <td>https://foo
   </td>
   <td>true
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>URL
   </td>
   <td>http://bar
   </td>
   <td>false
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h2 id="combining-data-streams">Combining Data Streams</h2>

<p>A data stream is the output from a singular yield() function. A single table stream contains one or more tables. There are two primary ways that users can combine data streams together:</p>

<ol>
  <li>Joining allows you to perform an inner join on two data streams. Performing a join expands the width of the data.</li>
  <li>Unioning allows you to concatenate two or more streams into a single output stream. Performing a join expands the height of the data.</li>
</ol>

<h3 id="join">Join</h3>

<p>Joining merges two input streams into a single output stream based on columns with equal values. There are two Flux functions for joining data:</p>

<ol>
  <li><a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/built-in/transformations/join/">join()</a>: The join() function takes the two data streams as input parameters and returns a joined table stream.</li>
  <li><a href="https://docs.influxdata.com/influxdb/cloud/reference/flux/stdlib/experimental/join/">experimental.join()</a>:  The experimental.join() function is a more performant version of the join() function.</li>
</ol>

<p>Joining your data results in a table stream output with an increased width.</p>

<h3 id="math-across-measurements">Math across measurements</h3>

<p>The most common reason for joining data is to perform math across measurements. To illustrate how to perform math across measurements, imagine the following scenario:</p>

<p>You are an operator at a chemical plant, and you need to monitor the temperatures of a counter-current heat exchanger. You collect temperatures of the cold (TC) and hot (TH) streams from four different temperature sensors. There are two inlet (Tc2, Th1) sensors and two outlet (Tc1, Th2) sensors at positions x1 and x2 respectively.</p>

<p id="gdcalert10"><span style="color: red; font-weight: bold">&gt;&gt;&gt;&gt;&gt;  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br />(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br /><span style="color: red; font-weight: bold">&gt;&gt;&gt;&gt;&gt; </span></p>

<p><img src="images/image3.png" alt="alt_text" title="image_tooltip" /></p>

<p>After making some assumptions, you can calculate the efficiency of heat transfer with this formula:</p>

<p id="gdcalert11"><span style="color: red; font-weight: bold">&gt;&gt;&gt;&gt;&gt;  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br />(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br /><span style="color: red; font-weight: bold">&gt;&gt;&gt;&gt;&gt; </span></p>

<p><img src="images/image4.png" alt="alt_text" title="image_tooltip" /></p>

<p>Where…</p>

<ul>
  <li>ɳ is the efficiency of the heat transfer</li>
  <li>Tc2 is the the temperature of the cold stream at position x2.</li>
  <li>Tc1 is the temperature of the cold stream at position x1.</li>
  <li>Th1 is the the temperature of the hot stream at position x1.</li>
  <li>Th2 is the temperature of the hot stream at position x2.</li>
</ul>

<p>You collect temperature reading from each sensor at 2 different times for a total of 8 points with the following schema:</p>

<ul>
  <li>1 bucket: sensors</li>
  <li>4 measurements: Tc1, Tc2, Th1, Th2</li>
  <li>1 Field: temperature</li>
</ul>

<p>Since the temperature readings are stored in different measurements, you need to join the data in order to calculate the efficiency.</p>

<p>First, I want to gather the temperature readings for each sensor. I start with Th1. I need to prepare the data. I drop the “_start” and “_stop” columns because I’m not performing any group by’s or windowing. Dropping these columns is by no means necessary, it just simplifies the example. I will just be performing math across values on identical timestamps, so I keep the “_time” column.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Th1</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">sensors</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">d</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Th1</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">temperature</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Th1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>Th1
   </td>
   <td>temperature
   </td>
   <td>80.90
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>Th1
   </td>
   <td>temperature
   </td>
   <td>81.00
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Th2</span> <span class="o">=</span> <span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">sensors</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">d</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Th2</span><span class="dl">"</span> <span class="nx">and</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">temperature</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Th2</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>Th2
   </td>
   <td>temperature
   </td>
   <td>70.2
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>Th2
   </td>
   <td>temperature
   </td>
   <td>71.6
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Next, join the two tables.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">TH</span> <span class="o">=</span> <span class="nx">join</span><span class="p">(</span><span class="nx">tables</span><span class="p">:</span> <span class="p">{</span><span class="nl">Th1</span><span class="p">:</span> <span class="nx">Th1</span><span class="p">,</span> <span class="nx">Th2</span><span class="p">:</span> <span class="nx">Th2</span><span class="p">},</span> <span class="nx">on</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement_Th1
   </td>
   <td>_measurement_Th2
   </td>
   <td>_field
   </td>
   <td>_value_Th1
   </td>
   <td>_value_Th2
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>Th1
   </td>
   <td>Th2
   </td>
   <td>temperature
   </td>
   <td>80.90
   </td>
   <td>70.2
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>Th1
   </td>
   <td>Th2
   </td>
   <td>temperature
   </td>
   <td>81.00
   </td>
   <td>71.6
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>The join() function takes a key table pair as input to the <code class="language-plaintext highlighter-rouge">tables</code> parameter and column names to the <code class="language-plaintext highlighter-rouge">on</code> parameter. The join() function only executes inner joins and joins all columns with equal values. The _time and _field columns have equal values where the _value and _measuremnt columns do not. The table key is appended to the column name to trace like columns with different values back to their input table.  Any columns that aren’t included in the <code class="language-plaintext highlighter-rouge">on </code>parameter won’t be joined.</p>

<p>Next, apply this logic to the cold stream as well:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">TC</span> <span class="o">=</span> <span class="nx">join</span><span class="p">(</span><span class="nx">tables</span><span class="p">:</span> <span class="p">{</span><span class="nl">Tc1</span><span class="p">:</span> <span class="nx">Tc1</span><span class="p">,</span> <span class="nx">Tc2</span><span class="p">:</span> <span class="nx">Tc2</span><span class="p">},</span> <span class="nx">on</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">])</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement_Tc1
   </td>
   <td>_measurement_Tc2
   </td>
   <td>_field
   </td>
   <td>_value_Tc1
   </td>
   <td>_value_Tc2
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>Tc1
   </td>
   <td>Tc2
   </td>
   <td>temperature
   </td>
   <td>50.50
   </td>
   <td>60.3
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>Tc1
   </td>
   <td>Tc2
   </td>
   <td>temperature
   </td>
   <td>51.00
   </td>
   <td>59.3
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Next, join TC with TH and calculate the efficiency. For the sake of simplicity we’ll drop the measurement columns as well.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">THTC</span> <span class="o">=</span> <span class="nx">join</span><span class="p">(</span><span class="nx">tables</span><span class="p">:</span> <span class="p">{</span><span class="nl">TH</span><span class="p">:</span> <span class="nx">TH</span><span class="p">,</span> <span class="nx">TC</span><span class="p">:</span> <span class="nx">TC</span><span class="p">},</span> <span class="nx">on</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">])</span>
<span class="o">|&gt;</span> <span class="nx">drop</span><span class="p">(</span> <span class="nx">columns</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_measurement_Th1</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_measurement_Th2</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_measurement_Tc1</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">_measurement_Tc2</span><span class="dl">"</span><span class="p">])</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TCTH</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_field
   </td>
   <td>_value_Th1
   </td>
   <td>_value_Th2
   </td>
   <td>_value_Tc1
   </td>
   <td>_value_Tc2
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>temperature
   </td>
   <td>80.90
   </td>
   <td>70.2
   </td>
   <td>50.50
   </td>
   <td>60.3
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>temperature
   </td>
   <td>81.00
   </td>
   <td>71.6
   </td>
   <td>51.00
   </td>
   <td>59.3
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<p>Finally, I can use the map() to calculate the efficiency across all of the measurements. This is what the code looks like all together:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">TCTH</span>
<span class="o">|&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">r</span> <span class="kd">with</span> <span class="nx">efficiency</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value_Tc2</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value_Tc1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">_value_Th1</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value_Th2</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">efficiency</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>I can see that the heat transfer efficiency has decreased over time.</p>

<table>
  <tr>
   <td>Not In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_field
   </td>
   <td>_value_Th1
   </td>
   <td>_value_Th2
   </td>
   <td>_value_Tc1
   </td>
   <td>_value_Tc2
   </td>
   <td>efficiency 
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0 
   </td>
   <td>temperature
   </td>
   <td>80.90
   </td>
   <td>70.2
   </td>
   <td>50.50
   </td>
   <td>60.3
   </td>
   <td>92
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>temperature
   </td>
   <td>81.00
   </td>
   <td>71.6
   </td>
   <td>51.00
   </td>
   <td>59.3
   </td>
   <td>88
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<h3 id="union">Union</h3>

<p>The <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/union/">union()</a> function allows you to combine one more table stream which results in a table stream output with an increased table length. Union is frequently used to:</p>

<ul>
  <li>Merge data across measurements or tags.</li>
  <li>Merge transformed data with the original data.</li>
  <li>Merge data with different time ranges to make data continuous.</li>
</ul>

<p>For example imagine we had the following data: \</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rcc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rcc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement2
   </td>
   <td>field2
   </td>
   <td>4.0
   </td>
   <td>rcc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement2
   </td>
   <td>field2
   </td>
   <td>5.0
   </td>
   <td>rcc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement3
   </td>
   <td>field3
   </td>
   <td>3.0
   </td>
   <td>rcc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement3
   </td>
   <td>field3
   </td>
   <td>7.0
   </td>
   <td>rcc3339time2
   </td>
  </tr>
</table>

<p>For example we could uses array.from() to construct that example:  <br />
<code class="language-plaintext highlighter-rouge">import "experimental"</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">array</span><span class="dl">"</span>

<span class="nx">rfc3339time1</span> <span class="o">=</span> <span class="nx">experimental</span><span class="p">.</span><span class="nx">subDuration</span><span class="p">(</span><span class="nx">d</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="nx">m</span><span class="p">,</span> <span class="k">from</span><span class="p">:</span> <span class="nx">now</span><span class="p">())</span>
<span class="nx">rfc3339time2</span> <span class="o">=</span> <span class="nx">experimental</span><span class="p">.</span><span class="nx">subDuration</span><span class="p">(</span><span class="nx">d</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="nx">m</span><span class="p">,</span> <span class="k">from</span><span class="p">:</span> <span class="nx">now</span><span class="p">())</span>

<span class="nx">data1</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">rows</span><span class="p">:</span> <span class="p">[</span>
<span class="p">{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time1</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">},</span>
<span class="p">{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time2</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">}])</span>

<span class="nx">data2</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">rows</span><span class="p">:</span> <span class="p">[{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time1</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field2</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement2</span><span class="dl">"</span><span class="p">},</span>
<span class="p">{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time2</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field2</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement2</span><span class="dl">"</span><span class="p">}])</span>

<span class="nx">data3</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">rows</span><span class="p">:</span> <span class="p">[{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time1</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field3</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement3</span><span class="dl">"</span><span class="p">},</span>
<span class="p">{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">rfc3339time2</span><span class="p">,</span> <span class="na">_value</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="na">_field</span><span class="p">:</span> <span class="dl">"</span><span class="s2">field3</span><span class="dl">"</span><span class="p">,</span> <span class="na">_measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">measurement3</span><span class="dl">"</span><span class="p">}])</span>
</code></pre></div></div>

<p>Now we might use union() to combine the three table streams together and pivot on the field and measurement:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">union</span><span class="p">(</span><span class="nx">tables</span><span class="p">:</span> <span class="p">[</span><span class="nx">data1</span><span class="p">,</span> <span class="nx">data2</span><span class="p">,</span> <span class="nx">data3</span><span class="p">])</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">after union</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">pivot</span><span class="p">(</span><span class="nx">rowKey</span><span class="p">:[</span><span class="dl">"</span><span class="s2">_time</span><span class="dl">"</span><span class="p">],</span> <span class="nx">columnKey</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_field</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">],</span> <span class="nx">valueColumn</span><span class="p">:</span> <span class="dl">"</span><span class="s2">_value</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">after pivot</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Where the first yield() function returns “after union”:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1.0
   </td>
   <td>rcc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>2.0
   </td>
   <td>rcc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement2
   </td>
   <td>field2
   </td>
   <td>4.0
   </td>
   <td>rcc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement2
   </td>
   <td>field2
   </td>
   <td>5.0
   </td>
   <td>rcc3339time2
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement3
   </td>
   <td>field3
   </td>
   <td>3.0
   </td>
   <td>rcc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>measurement3
   </td>
   <td>field3
   </td>
   <td>7.0
   </td>
   <td>rcc3339time2
   </td>
  </tr>
</table>

<p>The second yield() function returns “after pivot”</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>In Group Key
   </td>
   <td>In Group Key
   </td>
   <td>Not In Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_field1_measurement1
   </td>
   <td>_field2_measurement2
   </td>
   <td>_field3_measurement3
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>1.0
   </td>
   <td>4.0
   </td>
   <td>3.0
   </td>
   <td>rcc3339time1
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>2.0
   </td>
   <td>5.0
   </td>
   <td>7.0
   </td>
   <td>rcc3339time2
   </td>
  </tr>
</table>

<p>Using union() and pivot in this way allows you to achieve a result similar to using a join() function. However, unlike the join() function, the union() function allows you to combine more than two tables together.</p>

<h2 id="accessing-external-data-sources">Accessing External Data Sources</h2>

<p>You can use Flux to bring in data from a variety of other sources including SQL databases, other InfluxDB Cloud Accounts, Annotated CSV from a URL, and JSON.</p>

<h3 id="the-flux-sql-package">The Flux SQL package</h3>

<p>You can use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/sql/">Flux SQL package</a> to query and write to a variety of SQL data source including:</p>

<ul>
  <li>Amazon RDS</li>
  <li>Athena</li>
  <li>Google BigQuery</li>
  <li>CockroachDB</li>
  <li>MariaDB</li>
  <li>MySQL</li>
  <li>Percona</li>
  <li>PostgreSQL</li>
  <li>SAP HANA</li>
  <li>Snowflake</li>
  <li>Microsoft SQL Server</li>
  <li>SQLite</li>
</ul>

<p>Use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/sql/from/">sql.from()</a> function to query a SQL source. For example, to query a local Postgres instance use the following Flux query: <br />
<code class="language-plaintext highlighter-rouge">import "sql"</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">sql</span><span class="p">.</span><span class="k">from</span><span class="p">(</span>
  <span class="nx">driverName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">postgres</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">dataSourceName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">postgresql://user:password@localhost</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">query</span><span class="p">:</span><span class="dl">"</span><span class="s2">SELECT * FROM TestTable</span><span class="dl">"</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/sql/to/">sql.to()</a> function to write data to SQL database. For, example to write data to a local MySQL instance use the following Flux query: <br />
<code class="language-plaintext highlighter-rouge">import "sql"</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span>
<span class="o">|&gt;</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">to</span><span class="p">(</span>
  <span class="nx">driverName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">mysql</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">dataSourceName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">username:password@tcp(localhost:3306)/dbname?param=value</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">table</span><span class="p">:</span> <span class="dl">"</span><span class="s2">example_table</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">batchSize</span><span class="p">:</span> <span class="mi">10000</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Kee the following data requirements in mind when using the sql.to() function:</p>

<ul>
  <li>Data in the steam must have the same column names as your SQL database. Use a combination of drop(), keep(), map(), and rename() to prepare your data before using the sql.to() function.</li>
  <li>Remember your SQL schema rules. All data that doesn’t conform to your SQL schema rules will be dropped. Use the map() function to conform data to our SQL schema rules.</li>
</ul>

<h3 id="csv">CSV</h3>

<p>You can use Flux to import a Raw CSV or Annotated CSV from a URL (or from a local file) with the csv.from() functions. There are two csv.from() functions:</p>

<ol>
  <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/experimental/csv/from/">csv.from()</a> from the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/experimental/csv/">Flux experimental CSV package</a> which supports Annotated CSV</li>
  <li><a href="https://docs.influxdata.com/flux/v0.x/stdlib/csv/from/#csv">csv.from()</a> from stdlib which supports Annotated or Raw CSV</li>
</ol>

<h4 id="experimental-csvfrom">experimental csv.from()</h4>

<p>Use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/experimental/csv/from/">csv.from()</a> function from the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/experimental/csv/">Flux experimental CSV package</a> to retrieve an Annotated CSV from a URL. For example the <a href="https://docs.influxdata.com/influxdb/cloud/reference/sample-data/#noaa-water-sample-data">NOAA water sample data</a> pulls data from an Annotated CSV:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">experimental/csv</span><span class="dl">"</span>

<span class="nx">csv</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">https://influx-testdata.s3.amazonaws.com/noaa.csv</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Note:</strong> You can also upload Annotated CSV from a <a href="https://docs.influxdata.com/flux/v0.x/stdlib/csv/from/#file">local file</a> with the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/csv/from/">csv.from()</a> function stdlib with the <a href="https://docs.influxdata.com/influxdb/cloud/tools/repl/">Flux REPL</a>. You need to <a href="https://github.com/influxdata/flux/#getting-started">build the Flux REPL from source</a> and use it to access your local file system. This version of csv.from() also returns a stream of tables from Annotated CSV stored in a Flux variable.</p>

<h4 id="csvfrom">csv.from()</h4>

<p>Use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/csv/from/#csv">csv.from()</a> function from stdlib to retrieve a Raw CSV from a URL. For example you can use the csv.from() function to parse CSV data from API and write it to InfluxDB in a task. A great example of this can be found in the Earthquake Feed Ingestion task from the <a href="https://github.com/influxdata/community-templates/tree/master/earthquake_usgs">Earthquake Command Center Community</a> Template.  Here is the relevant Flux from that task: <br />
<code class="language-plaintext highlighter-rouge">onedayago = strings.trimSuffix(v: string(v: date.truncate(t: experimental.subDuration(d: 1d, from: now()), unit: 1m)), suffix: ".000000000Z")</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">csv_data_url</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://earthquake.usgs.gov/fdsnws/event/1/query?format=csv&amp;starttime=</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">onedayago</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">&amp;includedeleted=true&amp;orderby=time-asc</span><span class="dl">"</span>
<span class="nx">csv_data</span> <span class="o">=</span> <span class="nx">string</span><span class="p">(</span><span class="nx">v</span><span class="p">:</span> <span class="nx">http</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">url</span><span class="p">:</span> <span class="nx">csv_data_url</span><span class="p">).</span><span class="nx">body</span><span class="p">)</span>
<span class="nx">states</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Alaska</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">California</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">CA</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Hawaii</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Idaho</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Kansas</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">New Mexico</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Nevada</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">North Carolina</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Oklahoma</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Oregon</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Washington</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Utah</span><span class="dl">"</span><span class="p">]</span>
<span class="nx">countries_dictionary</span> <span class="o">=</span> <span class="nx">dict</span><span class="p">.</span><span class="nx">fromList</span><span class="p">(</span><span class="nx">pairs</span><span class="p">:</span> <span class="p">[{</span><span class="na">key</span><span class="p">:</span> <span class="dl">"</span><span class="s2">MX</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Mexico</span><span class="dl">"</span><span class="p">}])</span>

<span class="nx">csv</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">csv</span><span class="p">:</span> <span class="nx">csv_data</span><span class="p">,</span> <span class="nx">mode</span><span class="p">:</span> <span class="dl">"</span><span class="s2">raw</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>First the user builds their URL. Since this is a task, or a Flux script that’s executed on a schedule, the user wants to build their URL with a dynamic starttime value. They use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/experimental/subduration/">experimental.Subduration()</a> function to get the timestamp from -1d. Then they truncate the timestamp with <a href="https://docs.influxdata.com/flux/v0.x/stdlib/date/truncate/">date.truncate()</a> to round the timestamp down to the last minute or <code class="language-plaintext highlighter-rouge">".000000000Z"</code> . The <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/string/">string()</a> function is used to convert the timestamp into a string and the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/strings/trimsuffix/">strings.trimSuffix()</a> function removes the subseconds to format the starttime into the required format as specified by the <a href="https://earthquake.usgs.gov/fdsnws/event/1/">USGS Earthquake API</a>. Next they use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/experimental/http/get/">http.get()</a> function to submit an HTTP GET request to the <a href="https://earthquake.usgs.gov/fdsnws/event/1/">USGS Earthquake API</a>. Finally they use the csv.from() function to parse the CSV.</p>

<p>To learn about how to install a Community Template, please look at the</p>

<h3 id="json">JSON</h3>

<p>Use the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/experimental/json/parse/">json.parse()</a> function from the  <a href="https://docs.influxdata.com/flux/v0.x/stdlib/experimental/json/">Flux experimental JSON package</a> to return values from a JSON. Like the example above, you can also use json.parse() with http.get() to parse a HTTP GET JSON response and convert it to a Flux table:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">array</span><span class="dl">"</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">experimental/json</span><span class="dl">"</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">experimental/http</span><span class="dl">"</span>
<span class="nx">resp</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">https://api.openweathermap.org/data/2.5/weather?q=London,uk&amp;APPID=0xx2</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">jsonData</span> <span class="o">=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">body</span><span class="p">)</span>
<span class="nx">array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">rows</span><span class="p">:</span> <span class="p">[{</span><span class="na">_time</span><span class="p">:</span> <span class="nx">now</span><span class="p">(),</span> <span class="na">_value</span><span class="p">:</span> <span class="nx">float</span><span class="p">(</span><span class="na">v</span><span class="p">:</span><span class="nx">jsonData</span><span class="p">.</span><span class="nx">main</span><span class="p">.</span><span class="nx">temp</span><span class="p">)}])</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">()</span>
</code></pre></div></div>

<p>Which produces the following table:</p>

<table>
  <tr>
   <td>Not in Group Key
   </td>
   <td>Not Iin Group Key
   </td>
   <td>Not In Group Key
   </td>
  </tr>
  <tr>
   <td>table
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>0
   </td>
   <td>285.33
   </td>
   <td>rcc3339time1
   </td>
  </tr>
</table>

<p>Where the <a href="https://openweathermap.org/current">OpenWeatherMap current weather data API</a> yields the following HTTP GET JSON response: \</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"coord"</span><span class="p">:{</span><span class="nl">"lon"</span><span class="p">:</span><span class="mf">-0.1257</span><span class="p">,</span><span class="nl">"lat"</span><span class="p">:</span><span class="mf">51.5085</span><span class="p">},</span><span class="nl">"weather"</span><span class="p">:[{</span><span class="nl">"id"</span><span class="p">:</span><span class="mi">801</span><span class="p">,</span><span class="nl">"main"</span><span class="p">:</span><span class="s2">"Clouds"</span><span class="p">,</span><span class="nl">"description"</span><span class="p">:</span><span class="s2">"few clouds"</span><span class="p">,</span><span class="nl">"icon"</span><span class="p">:</span><span class="s2">"02n"</span><span class="p">}],</span><span class="nl">"base"</span><span class="p">:</span><span class="s2">"stations"</span><span class="p">,</span><span class="nl">"main"</span><span class="p">:{</span><span class="nl">"temp"</span><span class="p">:</span><span class="mf">285.33</span><span class="p">,</span><span class="nl">"feels_like"</span><span class="p">:</span><span class="mf">284.67</span><span class="p">,</span><span class="nl">"temp_min"</span><span class="p">:</span><span class="mf">282.94</span><span class="p">,</span><span class="nl">"temp_max"</span><span class="p">:</span><span class="mf">287.35</span><span class="p">,</span><span class="nl">"pressure"</span><span class="p">:</span><span class="mi">1024</span><span class="p">,</span><span class="nl">"humidity"</span><span class="p">:</span><span class="mi">79</span><span class="p">},</span><span class="nl">"visibility"</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span><span class="nl">"wind"</span><span class="p">:{</span><span class="nl">"speed"</span><span class="p">:</span><span class="mf">2.11</span><span class="p">,</span><span class="nl">"deg"</span><span class="p">:</span><span class="mi">254</span><span class="p">,</span><span class="nl">"gust"</span><span class="p">:</span><span class="mf">4.63</span><span class="p">},</span><span class="nl">"clouds"</span><span class="p">:{</span><span class="nl">"all"</span><span class="p">:</span><span class="mi">21</span><span class="p">},</span><span class="nl">"dt"</span><span class="p">:</span><span class="mi">1633546918</span><span class="p">,</span><span class="nl">"sys"</span><span class="p">:{</span><span class="nl">"type"</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="nl">"id"</span><span class="p">:</span><span class="mi">2019646</span><span class="p">,</span><span class="nl">"country"</span><span class="p">:</span><span class="s2">"GB"</span><span class="p">,</span><span class="nl">"sunrise"</span><span class="p">:</span><span class="mi">1633500560</span><span class="p">,</span><span class="nl">"sunset"</span><span class="p">:</span><span class="mi">1633541256</span><span class="p">},</span><span class="nl">"timezone"</span><span class="p">:</span><span class="mi">3600</span><span class="p">,</span><span class="nl">"id"</span><span class="p">:</span><span class="mi">2643743</span><span class="p">,</span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"London"</span><span class="p">,</span><span class="nl">"cod"</span><span class="p">:</span><span class="mi">200</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="materialized-views-or-downsampling-tasks">Materialized Views or Downsampling Tasks</h2>

<p>Materialized views or downsampling is the process of converting high resolution data to lower resolution aggregates. Downsampling is an important practice in time series database management because it allows users to preserve disk space while retaining low precision trends of their data over long periods of time. Users typically apply an aggregate or selector function to their high resolution data to create a materialized view of a lower resolution summary:</p>

<ul>
  <li><a href="https://docs.influxdata.com/flux/v0.x/function-types/#aggregates">Flux built-in aggregate transformations</a> like mean(), count(), sum() etc.</li>
  <li><a href="https://docs.influxdata.com/flux/v0.x/function-types/#selectors">Flux built-in selector transformations</a> like max(), min(), median(), etc.</li>
</ul>

<p>To downsample the data temperature from the Air Sensor sample dataset, you might perform the following query:  <br />
<code class="language-plaintext highlighter-rouge">from(bucket: "airsensor")</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="nx">d</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">aggregateWindow</span><span class="p">(</span><span class="nx">every</span><span class="p">:</span><span class="mi">1</span><span class="nx">d</span><span class="p">,</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">mean</span><span class="p">,</span> <span class="nx">createEmpty</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nx">to</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">airSensors_materializedView</span><span class="dl">"</span><span class="mi">0</span>
</code></pre></div></div>

<p>Use the to() function to write the data to a destination bucket. Destination buckets usually have a longer retention policy than the source bucket to conserve on disk space. Running this query will write the materialized view to the “airSensors_materializedView” bucket once. However, users typically perform downsampling on a schedule, or a task. Using tasks to create materialized views will be covered in detail in Part 3.</p>

:ET