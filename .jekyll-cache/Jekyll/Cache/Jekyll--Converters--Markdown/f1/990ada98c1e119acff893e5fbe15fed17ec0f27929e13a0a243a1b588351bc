I"KY<h1 class="no_toc" id="introduction-to-flux">Introduction to Flux</h1>

<h2 class="no_toc text-delta" id="table-of-contents">Table of contents</h2>

<ol id="markdown-toc">
  <li><a href="#basic-flux-concepts" id="markdown-toc-basic-flux-concepts">Basic Flux Concepts</a>    <ol>
      <li><a href="#flux-is-a-functional-language" id="markdown-toc-flux-is-a-functional-language">Flux is a Functional Language</a></li>
      <li><a href="#a-function-body-can-be-multiline-which-is-handled-syntactically-as-such" id="markdown-toc-a-function-body-can-be-multiline-which-is-handled-syntactically-as-such">A function body can be multiline, which is handled syntactically as such:</a></li>
      <li><a href="#declarative" id="markdown-toc-declarative">Declarative</a></li>
      <li><a href="#flux-is-strongly-and-statically-typed" id="markdown-toc-flux-is-strongly-and-statically-typed">Flux Is Strongly And Statically Typed</a></li>
      <li><a href="#flux-objects-are-immutable" id="markdown-toc-flux-objects-are-immutable">Flux Objects Are Immutable</a></li>
      <li><a href="#flux-parameters-are-named" id="markdown-toc-flux-parameters-are-named">Flux Parameters Are Named</a></li>
      <li><a href="#flux-parameter-types-can-be-overloaded" id="markdown-toc-flux-parameter-types-can-be-overloaded">Flux Parameter Types Can Be Overloaded</a></li>
      <li><a href="#pipe-forwarding" id="markdown-toc-pipe-forwarding">Pipe Forwarding</a></li>
      <li><a href="#flux-operates-on-streams-of-tables" id="markdown-toc-flux-operates-on-streams-of-tables">Flux Operates on Streams of Tables</a></li>
      <li><a href="#flux-supports-only-very-limited-looping" id="markdown-toc-flux-supports-only-very-limited-looping">Flux Supports Only Very Limited Looping</a></li>
      <li><a href="#dot-vs-bracket-notation" id="markdown-toc-dot-vs-bracket-notation">Dot vs. Bracket Notation</a></li>
      <li><a href="#packages" id="markdown-toc-packages">Packages</a>        <ol>
          <li><a href="#built-in-functions" id="markdown-toc-built-in-functions">Built In Functions</a></li>
          <li><a href="#imports" id="markdown-toc-imports">Imports</a></li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<hr />

<h1 id="basic-flux-concepts">Basic Flux Concepts</h1>

<p>Flux is the native language of InfluxDB 2.0. Flux is used for:</p>

<ol>
  <li>Writing queries to retrieve data.</li>
  <li>Transforming and shaping data as needed.</li>
  <li>Integrating with other data sources.</li>
</ol>

<p>Flux is a functional language designed specifically to work with the InfluxDB data format. To get the most power out of Flux, it is very useful to understand the underlying InfluxDB data model and how it relates to your schema, so make sure to read and understand the section on designing your schema above.</p>

<p>In the previous section, you were exposed to “just enough” Flux, but there are some important flux concepts that are useful to understand.</p>

<h2 id="flux-is-a-functional-language">Flux is a Functional Language</h2>

<p>Flux is a functional language from the ground up. Most Flux code that you write is essentially creating and linking together functions. Functions can be explicitly named, or as often as not, anonymous, meaning you declare the function inline without naming it.</p>

<p>Earlier, we were introduced to a filter.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">filter() </code>is a function that itself takes a function as an argument. However, most commonly, the function for a filter is defined inline and supplied anonymously. Alternatively you could name the filter and use the filter name:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">afilter_function</span> <span class="o">=</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span>

<span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="nx">afilter_function</span><span class="p">)</span>
</code></pre></div></div>

<p>We can zero in a bit on the function my_filter_function and tease apart the components a bit more.</p>

<p>Because Flux is a functional language, functions are first class objects. So the first step is to specify the identifier (“my_filter_function”) and the assignment operator (“=”). The next part is the parameter list, in this case simple “r”, for row. Followed by the lambda operator(“ =&gt;”). Finally, the function body itself.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">afilter_function</span> <span class="o">=</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span>
</code></pre></div></div>

<h2 id="a-function-body-can-be-multiline-which-is-handled-syntactically-as-such">A function body can be multiline, which is handled syntactically as such:</h2>

<h2 id="declarative">Declarative</h2>

<p>Flux is a declarative language. This means that your Flux is executed to accomplish the expressed goal in the Flux code, and is not necessarily done in the specific manner that you specify. This boils down to the Flux execution engine applying a planner to optimize the order of operations that you have specified to achieve better performance. You will always get the results that you are asking for, but Flux may achieve them slightly differently than the specific manner in which you specified.</p>

<p>This will be covered in more depth in the section on optimization Flux.</p>

<h2 id="flux-is-strongly-and-statically-typed">Flux Is Strongly And Statically Typed</h2>

<p>The Flux language is strongly typed. However, the typing is implicit. While you do not need to declare the types of your objects, the types are inferred when your program is run, and type mismatches cause errors.</p>

<p>Additionally, you cannot change the type of an object in Flux at run time. The type of an object is immutable.</p>

<h2 id="flux-objects-are-immutable">Flux Objects Are Immutable</h2>

<p>The value of an object is also immutable. For example:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">astring</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hi</span><span class="dl">"</span>
<span class="nx">astring</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">bye</span><span class="dl">"</span>
</code></pre></div></div>

<p>Will result in an error:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">2</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span> <span class="nx">variable</span> <span class="dl">"</span><span class="s2">astring</span><span class="dl">"</span> <span class="nx">reassigned</span>
</code></pre></div></div>

<p>Note that data in tables is NOT immutable. This will be covered in depth in the section on transforming data.</p>

<h2 id="flux-parameters-are-named">Flux Parameters Are Named</h2>

<p>With the exception of tables passed through the pipe forward operator, all Flux parameters are named. This makes your Flux code somewhat more self documenting, but also allows for more non-breaking changes to the Flux language.</p>

<h2 id="flux-parameter-types-can-be-overloaded">Flux Parameter Types Can Be Overloaded</h2>

<p>In many cases, a single parameter can accept arguments of multiple types. This is covered in detail in the case of the <a href="/time-to-awesome/docs/part-2/querying-and-data-transformations/#range">range() section</a> in the next section.</p>

<h2 id="pipe-forwarding">Pipe Forwarding</h2>

<p>Flux is designed to transform data by piping the data between functions, each function transforming the data in turn. The operator for this is the pipe forward operator “<code class="language-plaintext highlighter-rouge">|&gt;</code>”.</p>

<p>So you can see the following code starts with a <code class="language-plaintext highlighter-rouge">from()</code>, and then pipe forwards the results of that from to <code class="language-plaintext highlighter-rouge">range()</code>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="nx">m</span><span class="p">)</span>
</code></pre></div></div>

<p>That can then be pipe forwarded into more functions, for example, <code class="language-plaintext highlighter-rouge">filter()</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucket1</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="nx">m</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>As discussed above, a function body is defined with a set of parameters, the lambda operator, and the function operations. Additionally, when calling a function, all parameters are required named parameters. However, pipe forwarding has an implicit argument being passed between the functions, which is the stream of tables that was modified by the previous function.</p>

<p>A function that can be to the right of the pipe forward operator declares this with a special designation in it’s parameter list, the “pipe receive literal.”</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nx">tables</span><span class="o">=&lt;-</span><span class="p">)</span>
</code></pre></div></div>

<p>So, a function body that accepts pipe forwarded data looks like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">functionName</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tables</span><span class="o">=&lt;-</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">tables</span> <span class="o">|&gt;</span> <span class="nx">functionOperations</span>
</code></pre></div></div>

<p>A practical example is the application of a set of common filters:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">afilter_function</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tables</span><span class="o">=&lt;-</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_field</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">field1</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_value</span> <span class="o">&gt;</span> <span class="mf">80.0</span><span class="p">)</span>

<span class="k">from</span><span class="p">(</span><span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bucketa</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="nx">m</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">afilter_function</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="flux-operates-on-streams-of-tables">Flux Operates on Streams of Tables</h2>

<p>The consequence of the pipe forward operator is that Flux functions operate on every row of every table applied to them. To review, as you write data to InfluxDB, it is written to the storage engine in separate tables, each with a unique combination of the measurement, tag value combination, and fields. When you query that data back, those tables are read and streamed to flux, and each row of each table is then passed through each function.</p>

<p>You cannot ask Flux to operate on one table, but not others. Nor can you ask Flux to operate on one row, but not others. Every row in every table will undergo the same transformations.</p>

<p><img src="/time-to-awesome/assets/images/image-26.png" alt="ui" /></p>

<h2 id="flux-supports-only-very-limited-looping">Flux Supports Only Very Limited Looping</h2>

<p>Flux more or less does not allow looping. The closest thing to a loop capability is the <a href="https://docs.influxdata.com/flux/v0.x/stdlib/universe/map/">map()</a><code class="language-plaintext highlighter-rouge"> </code>function which applies a function to each record. In Flux, many of the things that you expect to accomplish in a loop, you accomplish rather by using successive functions that apply the transformations to the data.</p>

<h2 id="dot-vs-bracket-notation">Dot vs. Bracket Notation</h2>

<p>Because Flux takes inspiration from javascript, Flux supports both dot notation and bracket notation to access members. The following 2 lines are equivalent.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_measurement</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">_measurement</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">measurement1</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>There is no official convention to determine which to use, and both are equally valid. However, generated code often uses the bracket notation because if the generated code is based on user supplied data, there is a chance that the data itself has characters that can cause syntax errors. For example, if I generate a tag that includes a period, such as <code class="language-plaintext highlighter-rouge">sensor.001</code>, generated code that used dot notation will be broken:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">sensor</span><span class="p">.</span><span class="mi">001</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">astring</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">vs</span><span class="p">.</span>
<span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">:</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">[</span><span class="dl">"</span><span class="s2">sensor.001</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">astring</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>The first line would be a syntax error, so code generators typically would produce the second one.</p>

<h2 id="packages">Packages</h2>

<p>Flux comes with a large library of functions. These functions are organized into <a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/">packages</a>, collectively under the <a href="https://github.com/influxdata/flux/tree/master/stdlib">stdlib</a>.</p>

<h3 id="built-in-functions">Built In Functions</h3>

<p>The stdlib comes with a set of “<a href="https://docs.influxdata.com/influxdb/v2.0/reference/flux/stdlib/built-in/">built-in functions</a>,” meaning that you can use them without importance. These are the most commonly used functions, and all the functions introduced so far (<code class="language-plaintext highlighter-rouge">from()</code>,<code class="language-plaintext highlighter-rouge"> range()</code>, and <code class="language-plaintext highlighter-rouge">filter()</code>) are built-in.</p>

<h3 id="imports">Imports</h3>

<p>Other packages are designed for use with more specific domains, and must be imported in order to be used. So, for example, if you wanted to work with CSV within your flux function, you would need to import the csv package, like so:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">csv</span><span class="dl">"</span>
</code></pre></div></div>

<p>After which, functions in the csv package can be accessed with dot notation:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">csv</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">csv</span><span class="p">:</span> <span class="nx">csvData</span><span class="p">,</span> <span class="nx">mode</span><span class="p">:</span> <span class="dl">"</span><span class="s2">raw</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Bracket notation is also supported, which you may see occasionally:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">csv</span><span class="p">[</span><span class="dl">"</span><span class="s2">from</span><span class="dl">"</span><span class="p">](</span><span class="nx">csv</span><span class="p">:</span> <span class="nx">csvData</span><span class="p">,</span> <span class="nx">mode</span><span class="p">:</span> <span class="dl">"</span><span class="s2">raw</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Here’s a minimal example of importing the csv package and calling a function from it:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">csv</span><span class="dl">"</span>
<span class="nx">csvData</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">value,key</span><span class="se">\n</span><span class="s2">1,a</span><span class="dl">"</span>

<span class="nx">csv</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">csv</span><span class="p">:</span> <span class="nx">csvData</span><span class="p">,</span> <span class="nx">mode</span><span class="p">:</span> <span class="dl">"</span><span class="s2">raw</span><span class="dl">"</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="k">yield</span><span class="p">()</span>
</code></pre></div></div>

<p><a href="/time-to-awesome/docs/part-2/querying-and-data-transformations" class="btn btn-purple">Next Section</a></p>
:ET