I"<+<h1 class="no_toc" id="input-format-vs-output-format">Input Format vs Output Format</h1>

<h2 class="no_toc text-delta" id="table-of-contents">Table of contents</h2>

<ol id="markdown-toc">
  <li><a href="#line-protocol" id="markdown-toc-line-protocol">Line Protocol</a>    <ol>
      <li><a href="#adding-multiple-fields" id="markdown-toc-adding-multiple-fields">Adding multiple fields</a></li>
      <li><a href="#types-explained" id="markdown-toc-types-explained">Types explained</a></li>
      <li><a href="#type-conflicts" id="markdown-toc-type-conflicts">Type conflicts</a></li>
      <li><a href="#adding-tags" id="markdown-toc-adding-tags">Adding tags</a></li>
      <li><a href="#adding-timestamps" id="markdown-toc-adding-timestamps">Adding timestamps</a></li>
      <li><a href="#note-on-timestamp-precision" id="markdown-toc-note-on-timestamp-precision">Note on Timestamp Precision</a></li>
      <li><a href="#overwriting-points" id="markdown-toc-overwriting-points">Overwriting points</a></li>
    </ol>
  </li>
  <li><a href="#annotated-csv" id="markdown-toc-annotated-csv">Annotated CSV</a>    <ol>
      <li><a href="#raw-csv-vs-annotated-csv" id="markdown-toc-raw-csv-vs-annotated-csv">Raw CSV vs Annotated CSV</a></li>
      <li><a href="#header-row" id="markdown-toc-header-row">Header Row</a></li>
      <li><a href="#record-rows" id="markdown-toc-record-rows">Record Rows</a></li>
      <li><a href="#records-vs-points" id="markdown-toc-records-vs-points">Records vs Points</a></li>
      <li><a href="#annotation-rows" id="markdown-toc-annotation-rows">Annotation Rows</a></li>
    </ol>
  </li>
  <li><a href="#from-series-to-tables-on-disk" id="markdown-toc-from-series-to-tables-on-disk">From Series to Tables on Disk</a>    <ol>
      <li><a href="#adding-fields" id="markdown-toc-adding-fields">Adding Fields</a></li>
      <li><a href="#adding-tags-1" id="markdown-toc-adding-tags-1">Adding Tags</a></li>
    </ol>
  </li>
  <li><a href="#real-world-data" id="markdown-toc-real-world-data">Real World Data</a>    <ol>
      <li><a href="#exploring-the-real-word-data-schema-with-flux" id="markdown-toc-exploring-the-real-word-data-schema-with-flux">Exploring the Real Word Data Schema with Flux</a></li>
      <li><a href="#exercises-with-real-world-data" id="markdown-toc-exercises-with-real-world-data">Exercises with Real World Data</a></li>
    </ol>
  </li>
</ol>

<hr />

<p>The InfluxDB input format is line protocol. The InfluxDB output format is Annotated CSV.  The input format is different from the InfluxDB persistence. The Annotated CSV output can match the InfluxDB persistence format with simple Flux queries. However, can add Flux transformations to your query such that the Annotated CSV output doesn’t reflect the InfluxDB persistence format. Understanding these subtle differences is critical for good schema design and for using InfluxDB optimally.</p>

<h2 id="line-protocol">Line Protocol</h2>

<p>The smallest allowed  line of <a href="https://docs.influxdata.com/influxdb/cloud/reference/syntax/line-protocol/">line protocol</a> includes a measurement, a single field, and a value for that field. A measurement is the highest grouping of data inside a bucket. A field is  a part of that measurement and  defines a single point. Fields are separated by measurements by a space. So, the smallest readable line looks like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span>
</code></pre></div></div>

<h3 id="adding-multiple-fields">Adding multiple fields</h3>

<p>You need to supply at least one field, but you can supply as many as you need in a single line, separated by a comma:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span>
</code></pre></div></div>

<p>Line protocol is very compact, but each of the fields will be in their own series when stored in the database.  More on that in <a href="">From Series to Tables on Disk</a>.</p>

<h3 id="types-explained">Types explained</h3>

<p>The types of a field value can be an integer, a float, or a string. By default a number will be interpreted as a float. The addition of the  “i” after each number for my_field tells InfluxDB that I wanted those to be integers. Using quotes ensures that InfluxDB knows I want a string type.</p>

<h3 id="type-conflicts">Type conflicts</h3>

<p>Once you have created a series, you cannot change the type field type of the series. InfluxDB will reject the the following write:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span>
</code></pre></div></div>

<p>After having written this line:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span>
</code></pre></div></div>

<p>Notice how the field2 field value has been changed from a string to a float.</p>

<h3 id="adding-tags">Adding tags</h3>

<p>Tags are another kind of data that you can add to a line in line protocol. Tags are useful because they are automatically indexed by InfluxDB. Using and querying for tags allows you to significantly improve your query performance. Additionally, tags are useful for categorizing your queries.</p>

<p>Remember, a series is defined by a measurement(s), tag sets(s), and field key(s). Tags are defined after the measurement name, and separated from it by a comma. I can add a tag to the previous line protocol as such:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="mi">1626118680000000000</span>
<span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue2</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">2</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span> <span class="mi">1626118740000000000</span>
</code></pre></div></div>

<p>The introduction of the tag key, “tag1”, with 2 different tag values, “tagvalue1” and “tagvalue2” produces 6 series–3 series come from the different fields for each of the 2 tag values.</p>

<h3 id="adding-timestamps">Adding timestamps</h3>

<p>In cases where a timestamp is omitted from line protocol, InfluxDB will add a timestamp based on the current server time at the time of the write.</p>

<p>Letting InfluxDB automatically supply a timestamp is very convenient, but is likely too imprecise for your application, so you will typically supply a timestamp as well. InfluxDB expects timestamps to be <a href="https://docs.influxdata.com/influxdb/v2.0/reference/syntax/line-protocol/#timestamp">unix timestamps</a>. InfluxDB also expects the timestamps to be in nanosecond resolution, but the write API allows you to define lower resolution precision if needed.</p>

<p>The timestamp comes at the end of a line of line protocol and is separated from the last field value by a space. Supplying a timestamp to the above line protocol would look like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="mi">1626118680000000000</span>
<span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">2</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span> <span class="mi">1626118740000000000</span>
</code></pre></div></div>

<h3 id="note-on-timestamp-precision">Note on Timestamp Precision</h3>

<p>The native resolution of time stamps in InfluxDB is nanoseconds. In InfluxDB, the unit of resolution (for example nanosecond, microsecond, millisecond) is called the “precision” of the time stamp. For context:</p>

<ul>
  <li>There are 1,000 nanoseconds in a microsecond</li>
  <li>There are 1,000,000 nanoseconds in a millisecond</li>
  <li>There are 1,000,000,000 nanoseconds in a second</li>
</ul>

<p>This is important to keep in mind while constructing your application, because many systems do not handle nanosecond resolution, so it is necessary to convert between them.</p>

<p>Note that InfluxDB tools do allow you to define the precision of your timestamps, so when writing, you can allow InfluxDB to handle the conversion for you. This will be covered in Part 3.</p>

<h3 id="overwriting-points">Overwriting points</h3>

<p>You can overwrite points in InfluxDB when you write data with the same series and same timestamp. For example, if you wrote this line of line protocol to InfluxDB:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">2</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span> <span class="mi">1626118740000000000</span>
</code></pre></div></div>

<p>You would then overwrite the 3 points by writing this line next.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">10</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">overwritten</span><span class="dl">"</span> <span class="mi">1626118740000000000</span>
<span class="o">&lt;</span><span class="nx">more</span> <span class="nx">examples</span> <span class="nx">that</span> <span class="nx">include</span> <span class="nx">partial</span> <span class="nx">overwrites</span><span class="p">,</span> <span class="nx">subsets</span> <span class="k">of</span> <span class="nx">tags</span><span class="o">&gt;</span>
</code></pre></div></div>

<h2 id="annotated-csv">Annotated CSV</h2>

<p><a href="https://docs.influxdata.com/influxdb/cloud/reference/syntax/annotated-csv/">Annotated CSV</a> is the output format for InfluxDB. The annotated CSV output matches the InfluxDB persistence format <strong>with simple queries or when you don’t apply additional transformations to your data</strong>. Annotated CSV result is a stream of tables returned by Flux where each table represents a series <strong>for simple queries only</strong>. For example if you wrote this line protocol line to InfluxDB:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="nx">tagvalue1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span>
</code></pre></div></div>

<p>You would return the following full annotated CSV output when querying for all fields and tags (of which there are none) within the measurement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,long,string,string,string
#default,_result,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,0,rfc3339time1,rfc3339time2,2021-08-17T21:23:39.000000000Z,1,field1,Measurement1,tagvalue1
</code></pre></div></div>

<p>Remember, that line of line protocol produces 1 series which is why one table is included in the annotated CSV output.</p>

<h3 id="raw-csv-vs-annotated-csv">Raw CSV vs Annotated CSV</h3>

<p>The first thing to notice about the output format of annotated CSV is that it resembles the CSV format that you’re familiar with. To easily distinguish between the two we’ll refer to CSV as Raw CSV. Unlike raw CSV, annotated CSV contains the following rows:</p>

<ul>
  <li>Header Row</li>
  <li>Records Rows</li>
  <li>Annotation Rows</li>
</ul>

<h3 id="header-row">Header Row</h3>

<p>The header row is similar to any header row in a CSV. It describes the column names for your time series data.The header row is found below the 3 Annotation rows.  Our header row is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
</code></pre></div></div>

<p>Some of these headers are an intuitive translation from line protocol while others are not. The headers are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">result</code>. This column includes the name of the result as specified by the query. If no name is provided it will be empty.</li>
  <li><code class="language-plaintext highlighter-rouge">table</code>. This column contains a unique ID for each table in the annotated CSV output result. stream. In the example above we are only writing and querying for 1 series so the value of that column is set to 0 for that table.</li>
  <li><code class="language-plaintext highlighter-rouge">_start.</code>This column includes the start time for the time range over which you queried your data for. Specifying a range is necessary for any Flux query.</li>
  <li><code class="language-plaintext highlighter-rouge">_stop.</code>This column includes the stop time for the time range over which you queried your data for. Specifying a range is necessary for any Flux query.</li>
  <li><code class="language-plaintext highlighter-rouge">_time.</code>This column is the timestamp for your time series. The value of this column is either added upon write or included in the line protocol explicitly.</li>
  <li><code class="language-plaintext highlighter-rouge">_value</code>. This column contains the field values for the corresponding field keys in the same row under the <code class="language-plaintext highlighter-rouge">_field </code>column.</li>
  <li><code class="language-plaintext highlighter-rouge">_field</code>. This column contains the field keys.</li>
  <li><code class="language-plaintext highlighter-rouge">_measurement</code>. This column contains the name of the measurement.</li>
  <li><code class="language-plaintext highlighter-rouge">tag1</code>. This column contains the tag value for our <code class="language-plaintext highlighter-rouge">tag1</code> tag key.</li>
</ul>

<p>For the rest of this section you can ignore the values for the <code class="language-plaintext highlighter-rouge">_start, _stop, </code>and <code class="language-plaintext highlighter-rouge">result</code> columns. Those values are assigned by the user during query execution. For now, just focus on understanding the similarities between your line protocol input format and the resulting annotated CSV.</p>

<h3 id="record-rows">Record Rows</h3>

<p>The records row(s) is directly below the header row. These rows contain our time series data.  Each row contains one record. A record is a tuple of named values.  Each table contains at least one record. When querying for your time series without adding any additional Flux transformations, a table</p>

<h3 id="records-vs-points">Records vs Points</h3>

<p>Remember, a point is a datapoint from a series at a specific timestamp. A record can be a point but not always. For example, you could use Flux to drop all tag, field, and measurement columns. At this point the records in the annotated CSV wouldn’t reflect a point but rather time series data instead.</p>

<h3 id="annotation-rows">Annotation Rows</h3>

<p>The annotation rows are found in the first three lines of the full annotated CSV output. Annotations include metadata about your annotated CSV. When querying InfluxDB with the API, you can specify which headers you want to include in your annotated CSV output. All 3 headers are included by default when you export the results of your query through the InfluxDB UI.</p>

<p>The 3 annotations are:</p>

<ol>
  <li>
    <p>​​#group: A boolean that indicates the column is part of the <a href="https://v2.docs.influxdata.com/v2.0/query-data/flux/group-data/#group-keys">group key</a>. A group key is a list of columns for which every row in the table has the same value.  A column is part of the group key if its ​​#group annotation is set to ​​true.</p>

    <p><strong>Important Note:</strong> The exception is for the table column. The group key for the table is set to false because users can’t directly change the table number. The table record will always be the same across rows even though the group key is set to false.</p>
  </li>
  <li>#datatype: Describes the type of data or which line protocol element the column represents.</li>
  <li>#default: The value to use for rows with an empty value.</li>
</ol>

<p>If annotations confuse you, don’t worry. The importance of annotations will become apparent in subsequent sections of this book, specifically around understanding Flux. Additionally it’s worth mentioning that the​​ #group annotation is the most important annotation for using Flux successfully. For now, be aware that InfluxDB applies a default group key to your data so that the tables in your annotated CSV output will each represent a single series for simple queries. This default application of group keys is the result of the way that series are stored on disk, described in the following section.</p>

<h2 id="from-series-to-tables-on-disk">From Series to Tables on Disk</h2>

<p>Each series is stored as a table on disk. Data gets written to InfluxDB into buckets. When data is written to a bucket it is added to an appropriate table, or a new table is created if needed. Each table has exactly one measurement, one field, and a unique set of tag values. Indexes are created or amended on write to enable quickly finding these tables when queried. Additionally, all rows in all tables are indexed by time.</p>

<p>Some people consider InfluxDB to be a “schemaless” database. However, that is not really accurate. More accurately, InfluxDB is a “schema on write.” That is to say, InfluxDB does not require a schema to be defined beforehand nor enforce a schema on writes. Instead, Influxdb builds a schema implicitly based on the writes you do make.</p>

<p>While schema on write is a true convenience for developers, you should be cognizant of the schema that you are implicitly creating as you write data. A poorly designed schema can have a negative impact on things like ease of querying, performance, and cardinality.</p>

<p>In this section we’ll learn about how line protocol produces series which get stored as tables on disk.</p>

<h3 id="adding-fields">Adding Fields</h3>

<p>In this section we’ll break down how the line protocol is converted to series and written as tables in InfluxDB. Let’s review the line protocol examples above:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span>
<span class="nx">measurement1</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span>
</code></pre></div></div>

<p>When written, this will form 3 different time series with 2 points in each series, assuming each line was  written one minute apart. The data will then be persisted in three separate tables:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>2021-07-12T19:38:00.000000000Z
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>2021-07-12T19:39:00.000000000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>1
   </td>
   <td>2021-07-12T19:38:00.000000000Z
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field2
   </td>
   <td>2
   </td>
   <td>2021-07-12T19:39:00.000000000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field3
   </td>
   <td>a
   </td>
   <td>2021-07-12T19:38:00.000000000Z
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>field3
   </td>
   <td>b
   </td>
   <td>2021-07-12T19:39:00.000000000Z
   </td>
  </tr>
</table>

<p>This example provides the first insights into how the input format and the persistence/output format differ. Each series in InfluxDB is persisted with exactly one field, though line protocol allows writing with multiple fields. This is a critically important concept to understand, so it is worth repeating. <strong>The InfluxDB input format is different from the InfluxDB persistence and output format</strong>.</p>

<p>These tables represent the minimum data roles that can exist in a series. A series must have at a minimum:</p>

<ul>
  <li>A measurement name</li>
  <li>A field key</li>
  <li>A value for the field</li>
  <li>A time</li>
</ul>

<p>These are represented in the database with a leading “_”. The leading underscore conveys that these are “slots” in the series that are enforced by the storage engine, as well as helps to avoid naming conflicts with potential tag names.</p>

<p>When simply querying for this data, without adding any additional Flux transformations, the annotated CSV output looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#group,false,false,true,true,false,false,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,long,string,string
#default,_result,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement
,,0,rfc3339time1,rfc3339time2,2021-07-12T19:39:00.000000000Z,1,field1,measurement1
,,0,rfc3339time1,rfc3339time2,2021-07-12T19:38:00.00000000Z,1,field1,measurement1

#group,false,false,true,true,false,false,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,string,string,string
#default,_result,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement
,,1,rfc3339time1,rfc3339time2,2021-07-12T19:39:00.000000000Z,a,field3,measurement1
,,1,rfc3339time1,rfc3339time2,2021-07-12T19:38:00.00000000Z,b,field3,measurement1

#group,false,false,true,true,false,false,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,double,string,string
#default,_result,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement
,,2,rfc3339time1,rfc3339time2,2021-07-12T19:39:00.000000000Z,1,field2,measurement1
,,2,rfc3339time1,rfc3339time2,2021-07-12T19:38:00.000000000Z,2,field2,measurement1
</code></pre></div></div>

<p>Notice how the resulting annotated CSV contains 3 tables in the output. This is evident by the row separation and also by the value of the <code class="language-plaintext highlighter-rouge">table</code> column in the last stream of the table which is equal to 2 (remember annotated CSV counts the table results from 0). Group keys have been added to the data to produce these tables so that each table represents a series by default. Remember a column is part of a group key if all of the values in that column are identical within a single table. For example, the <code class="language-plaintext highlighter-rouge">time </code>and<code class="language-plaintext highlighter-rouge"> value </code>columns are assigned a <code class="language-plaintext highlighter-rouge">#group </code>annotation of ​​<code class="language-plaintext highlighter-rouge">false.</code> Setting the <code class="language-plaintext highlighter-rouge">#group </code>annotation to ​​<code class="language-plaintext highlighter-rouge">false</code> allows the different timestamps and field values of points across a single series to be included in the same table.</p>

<h3 id="adding-tags-1">Adding Tags</h3>

<p>Let’s review the line protocol example above with an added tag:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="mi">1626118680000000000</span>
<span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue2</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">2</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span> <span class="mi">1626118740000000000</span>
</code></pre></div></div>

<p>The introduction of tag1 produces the following 6 series:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>2021-07-12T19:38:00.000000000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field2
   </td>
   <td>1
   </td>
   <td>2021-07-12T19:38:00.000000000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>field3
   </td>
   <td>a
   </td>
   <td>2021-07-12T19:38:00.000000000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>2i
   </td>
   <td>2021-07-12T19:39:00.000000000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>field2
   </td>
   <td>2
   </td>
   <td>2021-07-12T19:39:00.000000000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>field3
   </td>
   <td>b
   </td>
   <td>2021-07-12T19:39:00.000000000Z
   </td>
  </tr>
</table>

<p>Ensure that you take the time to study and understand the relationship between the line protocol and the resulting tables as they are represented on disk by the storage engine. This relationship is critically important to achieving the most effective schema and querying for your application.</p>

<p>When simply querying for this data, without adding any additional Flux transformations the annotated CSV output looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,string,string,string,string
#default,_result,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,0,rfc3339time1,rfc3339time2,2021-07-12T19:39:000000000Z,b,field3,measurement1,tagvalue2

#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,double,string,string,string
#default,_result,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,1,rfc3339time1,rfc3339time2,2021-07-12T19:38:000000000Z,1,field2,measurement1,tagvalue1

#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,long,string,string,string
#default,_result,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,2,2021-01-18T20:59:37Z,2021-08-17T19:59:37.097Z,2021-07-12T19:38:000000000Z,1,field1,measurement1,tagvalue1

#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,string,string,string,string
#default,_result,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,3,rfc3339time1,rfc3339time2,2021-07-12T19:38:000000000Z,a,field3,measurement1,tagvalue1

#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,long,string,string,string
#default,_result,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,4,rfc3339time1,rfc3339time2,2021-07-12T19:39:000000000Z,2,field1,measurement1,tagvalue2

#group,false,false,true,true,false,false,true,true,true
#datatype,string,long,dateTime:RFC3339,dateTime:RFC3339,dateTime:RFC3339,double,string,string,string
#default,_result,,,,,,,,
,result,table,_start,_stop,_time,_value,_field,_measurement,tag1
,,5,rfc3339time1,rfc3339time2,2021-07-12T19:39:000000000Z,2,field2,measurement1,tagvalue2
</code></pre></div></div>

<p>Notice how the resulting annotated CSV contains 6 tables in the output. This is evident by the row separation and also by the value of the <code class="language-plaintext highlighter-rouge">table</code> column in the last stream of the table which is equal to 5 (remember annotated CSV counts the table results from 0). Group keys have been added to the data to produce these tables so that each table represents a series by default. Remember a column is part of a group key if all of the values in that column are identical within a single table. For example, the <code class="language-plaintext highlighter-rouge">time </code>column is assigned a <code class="language-plaintext highlighter-rouge">#group </code>annotation of ​​<code class="language-plaintext highlighter-rouge">false.</code> Setting the <code class="language-plaintext highlighter-rouge">#group </code>annotation to ​​<code class="language-plaintext highlighter-rouge">false</code> allows the different timestamps of points across a single series to be included in the same table. Conversely, the <code class="language-plaintext highlighter-rouge">_measurement </code>column is assigned a <code class="language-plaintext highlighter-rouge">#group </code>annotation of ​​<code class="language-plaintext highlighter-rouge">true.</code> The <code class="language-plaintext highlighter-rouge">_measurement</code> column is assigned a <code class="language-plaintext highlighter-rouge">#group </code>annotation of ​​<code class="language-plaintext highlighter-rouge">true</code>. Setting the <code class="language-plaintext highlighter-rouge">#group </code>annotation to ​​<code class="language-plaintext highlighter-rouge">true</code> enforces that all of the records in that table have the same measurement value. Remember, a series is identified by a unique combination of measurements, tag sets, and fields. If a table is to represent a single series, the table must contain records with the same measurement, tag sets, and fields across all of the rows.</p>

<p><strong>Important note:</strong> You can use Flux to manipulate the group keys and the resulting number of tables in the the output Annotated CSV table stream. We’ll learn about how to do this in later chapters.</p>

<p>For now, let’s focus on understanding how line protocol results in different series. We can extend the example by adding an additional tag, but in this case, note that there is only a single tag value for <code class="language-plaintext highlighter-rouge">tag2</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue3</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="mi">1626118680000000000</span>
<span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue2</span><span class="dl">"</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue3</span><span class="dl">"</span>  <span class="nx">field1</span><span class="o">=</span><span class="mi">2</span><span class="nx">i</span><span class="p">,</span><span class="nx">field2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="nx">field3</span><span class="o">=</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span> <span class="mi">1626118740000000000</span>
</code></pre></div></div>

<p>Again, each series is identified by their unique tag keys, tag values, and field key combinations.  Because a series is defined in part by a unique set of tag <em>values</em>, in this case, the introduction of tag2 does not change the table count in the underlying data model. When the introduction of a tag does not change the table count in the underlying data model, the tag is referred to as a <a href="https://docs.influxdata.com/influxdb/cloud/reference/glossary/#series-cardinality">dependent tag</a>:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>2021-07-12T19:38:00.000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>field2
   </td>
   <td>1
   </td>
   <td>2021-07-12T19:38:00.000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>field3
   </td>
   <td>a
   </td>
   <td>2021-07-12T19:38:00.000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>2i
   </td>
   <td>2021-07-12T19:39:00.000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>tagvalue2
   </td>
   <td>field2
   </td>
   <td>2
   </td>
   <td>2021-07-12T19:39:00.000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>tagvalue2
   </td>
   <td>field3
   </td>
   <td>b
   </td>
   <td>2021-07-12T19:39:00.000Z
   </td>
  </tr>
</table>

<p>To demonstrate the impact of combinations of tag values on the creation of time series, here are three lines of line protocol, but with only one field:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue4</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span> <span class="mi">1626118620000000000</span>
<span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue2</span><span class="dl">"</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue5</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">2</span><span class="nx">i</span> <span class="mi">1626118680000000000</span>
<span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue3</span><span class="dl">"</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue6</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">3</span><span class="nx">i</span> <span class="mi">1626118740000000000</span>
</code></pre></div></div>

<p>In those 3 lines there are 3 unique combinations of tag values and the single field, so, despite the presence of six total tag values, there are only 3 series created:</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue4
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>2021-07-12T19:37:00.000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue2
   </td>
   <td>tagvalue5
   </td>
   <td>field1
   </td>
   <td>2i
   </td>
   <td>2021-07-12T19:38:00.000Z
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue3
   </td>
   <td>tagvalue6
   </td>
   <td>field1
   </td>
   <td>3i
   </td>
   <td>2021-07-12T19:39:00.000Z
   </td>
  </tr>
</table>

<p>In this example, there are only 2 unique combinations of tag values:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue4</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">1</span><span class="nx">i</span> <span class="mi">1626118620000000000</span>
<span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue1</span><span class="dl">"</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue4</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">2</span><span class="nx">i</span> <span class="mi">1626118680000000000</span>
<span class="nx">measurement1</span><span class="p">,</span><span class="nx">tag1</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue2</span><span class="dl">"</span><span class="p">,</span><span class="nx">tag2</span><span class="o">=</span><span class="dl">"</span><span class="s2">tagvalue4</span><span class="dl">"</span> <span class="nx">field1</span><span class="o">=</span><span class="mi">3</span><span class="nx">i</span> <span class="mi">1626118740000000000</span>
</code></pre></div></div>

<p>As a result, the first series contains two points because those two points have the same combination of field name and tag values, whereas the third point has a different set of tag values.</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>tag1
   </td>
   <td>tag2
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>1i
   </td>
   <td>2021-07-12T19:37:00.000Z
   </td>
  </tr>
  <tr>
   <td>measurement1
   </td>
   <td>tagvalue1
   </td>
   <td>tagvalue2
   </td>
   <td>field1
   </td>
   <td>2i
   </td>
   <td>2021-07-12T19:38:00.000Z
   </td>
  </tr>
</table>

<tr>
   <td>_measurement

   </td>
   <td>tag1

   </td>
   <td>tag2

   </td>
   <td>_field

   </td>
   <td>_value

   </td>
   <td>_time

   </td>
  </tr>
<tr>
   <td>measurement1

   </td>
   <td>tagvalue3

   </td>
   <td>tagvalue4

   </td>
   <td>field1

   </td>
   <td>3i

   </td>
   <td>2021-07-12T19:39:00.000Z

   </td>
  </tr>

<h2 id="real-world-data">Real World Data</h2>

<p>There is an excellent <a href="https://github.com/influxdata/influxdb2-sample-data">repository of semi-live line protocol data</a> maintained by InfluxData. This is generally intended as sample data to help you get started exploring InfluxDB. Currently, 4 datasets are kept up to date there:</p>

<ol>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#air-sensor-sample-data">Air Sensor Data</a>: This dataset includes a single tag, which is an id for the specific air quality sensor that is reporting  3 fields, temperature, humidity, and carbon monoxide levels.</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#bird-migration-sample-data">Bird Migration Data</a>: This is geo-spatial dataset represents migratory movements of birds. It is tagged to aid geo-spacial querying.</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#noaa-ndbc-data">NOAA National Buoy Center Data</a>: This dataset  provides the latest observations from the NOAA NDBC network of buoys. It contains a large number of tags and fields.</li>
  <li><a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#usgs-earthquake-data">USGS Earthquake Data</a>. The United States Geological Survey (USGS) earthquake dataset contains seismic activity data. This is a very large dataset, and contains even more tags and fields.</li>
</ol>

<p>While you can simply copy the Flux from any of the real world sample datasets into the <strong>Script Editor</strong> in the <strong>Data Explorer</strong> and visualize the data. I recommend creating a bucket and using the to() function to write the data to that bucket, as described in <a href="/time-to-awesome/docs/part-1/introduction-to-influxdb/#write-and-query-sample-data">Write and Query Sample Data</a>) in Part 1. Writing the data to a bucket in InfluxDB allows you to use Flux to explore the schema of your dataset.</p>

<p><strong>Important Note:</strong> You might hit your series cardinality limit for Free Tier accounts if you write the larger datasets to InfluxDB. I recommend just writing the  <a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#air-sensor-sample-data">Air Sensor Data</a> if you’re using the Free Tier account.</p>

<p><strong>Important Note:</strong> This section recommends that you use the InfluxDB UI to write data to InfluxDB only because writing data with other tools hasn’t been covered yet. We recommend writing data with the CLI or VS Code. If you prefer developing in with those tools look at the</p>

<h3 id="exploring-the-real-word-data-schema-with-flux">Exploring the Real Word Data Schema with Flux</h3>

<p>Let us turn our attention to 2 real world data sets:  <a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#air-sensor-sample-data">Air Sensor Data</a> and the <a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#noaa-ndbc-data">NOAA National Buoy Center Data</a>. We’ll use Flux to get an understanding of our schema. Then we’ll run through some exercises to ensure our understanding of the relationship between the line protocol input format and the InfluxDB data model as persisted on disk by the storage engine.</p>

<p>We’ll start by focusing on the Air sensor dataset, as it is the simplest dataset. The a Air sensor dataset contains:</p>

<ul>
  <li>1 measurement: airSensors</li>
  <li>3 fields:
    <ul>
      <li>co</li>
      <li>humidity</li>
      <li>temperature</li>
    </ul>
  </li>
  <li>1 tag: sensor_id
    <ul>
      <li>8 sensor_id tag values</li>
    </ul>
  </li>
</ul>

<p>As you can see, the fields are the actual data, in this case all of type float, where the tag is metadata, defining which sensor produced the data.</p>

<p><a href="https://docs.influxdata.com/influxdb/cloud/query-data/flux/explore-schema/">Explore your data schema with Flux</a> to obtain the number of measurements, tag keys, tag values, and field keys in your data by using the schema package.</p>

<p>To get the number of fields in the airSensors measurement from the Air sensor sample dataset, run the following Flux query in your preferred tool (CLI, VS Code, InfluxDB UI):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">influxdata/influxdb/schema</span><span class="dl">"</span>

<span class="nx">schema</span><span class="p">.</span><span class="nx">measurementFieldKeys</span><span class="p">(</span>
  <span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span>
<span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">count</span><span class="p">()</span>
</code></pre></div></div>

<p>To get the number of tag keys in the airSensors measurement from the Air sensor sample dataset, run the following Flux query in your preferred tool (CLI, VS Code, InfluxDB UI):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">influxdata/influxdb/schema</span><span class="dl">"</span>

<span class="nx">schema</span><span class="p">.</span><span class="nx">measurementTagKeys</span><span class="p">(</span>
  <span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">airSensors</span><span class="dl">"</span>
<span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">count</span><span class="p">()</span>
</code></pre></div></div>

<p>To get the number of tag values for the sensor_id tag key in the airSensors measurement from the Air sensor sample dataset, use the following Flux query (CLI, VS Code, InfluxDB UI):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">influxdata/influxdb/schema</span><span class="dl">"</span>

<span class="nx">schema</span><span class="p">.</span><span class="nx">measurementTagValues</span><span class="p">(</span>
  <span class="nx">bucket</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Air sensor sample dataset</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">sensor_id</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">measurement</span><span class="p">:</span> <span class="dl">"</span><span class="s2">example-measurement</span><span class="dl">"</span>
<span class="p">)</span>
<span class="o">|&gt;</span> <span class="nx">count</span><span class="p">()</span>
</code></pre></div></div>

<p>We can repeat the same approach for the <a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#noaa-ndbc-data">NOAA National Buoy Center Data</a>. We find that the <a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#noaa-ndbc-data">NOAA National Buoy Center Data</a> has the following schema:</p>

<ul>
  <li>1 measurement: ndbc</li>
  <li>21 fields:
    <ul>
      <li>air_temp_degc</li>
      <li>avg _wave_period_sec</li>
      <li>dewpoint_temp_degc</li>
      <li>dominate_wave _period_sec</li>
      <li>gust_speed_mps</li>
      <li>lat</li>
      <li>lon</li>
      <li>pressure_temdancy_hpa</li>
      <li>sea_level_pressure_hpa</li>
      <li>sea_surface_temp_degc</li>
      <li>significant_Wave_height_m</li>
      <li>station_currents</li>
      <li>station_dart</li>
      <li>station_elev</li>
      <li>sation_met</li>
      <li>station_visibility_mei</li>
      <li>station_waterquality</li>
      <li>water_level_ft</li>
      <li>wave_dir_degt</li>
      <li>wind_dir_degt</li>
      <li>wind_spead_mps</li>
    </ul>
  </li>
  <li>5 tag keys:
    <ul>
      <li>station_id
        <ul>
          <li>113 station_id tag values</li>
        </ul>
      </li>
      <li>station_name
        <ul>
          <li>828</li>
        </ul>
      </li>
      <li>station_owner
        <ul>
          <li>57 station_owner tag values</li>
        </ul>
      </li>
      <li>station_pgm
        <ul>
          <li>6 station_pgm tag values</li>
        </ul>
      </li>
      <li>station_type
        <ul>
          <li>4 station_type tag values</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Again, note that the 21 fields are all the different kinds of data that might be collected by a weather station, whereas the 5 tags contain metadata about which stations collected it.</p>

<h3 id="exercises-with-real-world-data">Exercises with Real World Data</h3>

<p>Now that we understand the schema of the 2 real world data sets, <a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#air-sensor-sample-data">Air Sensor Data</a> and the <a href="https://docs.influxdata.com/influxdb/v2.0/reference/sample-data/#noaa-ndbc-data">NOAA National Buoy Center Data</a>, try to answer the following questions to test your understanding of schema design, line protocol, and</p>

<p>Question 1: How many series will be created by the Air Sensor Data given the schema above?</p>

<p>Answer 1: (1 sensor_id tag x 8 unique tag values) x (3 fields) = 4 x 3 = <strong>24</strong></p>

<p>Question 2: How many series will be created by the NOAA National Buoy Center Data given the schema above (assuming no tags are dependent tags)?</p>

<p>Answer 2: (1 station_id tag x 113 unique tag values) x (1 station_name tag x 828 unique tag values) x (1 station_name tag x 828 unique tag values) x (1 station_owner tag x 57 unique tag values) x (1 station_pgm tag x 6 unique tag values) x (1 station_type tag x 47 unique tag values) x (21 fields) = 113 x 828 x 56 x 6 x 47 x 21 = <strong>31028816448</strong></p>

<p>Question 3: How would the following line protocol form the Air sensor sample dataset be organized into tables on disk? And how many points are in each series?</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0100</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">71.17615703642676</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.12940716174776</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.5024058630839136</span> <span class="mi">1626537623000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0101</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">71.80350992863588</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">34.864121891949736</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.4925449578765155</span> <span class="mi">1626537623000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0102</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">72.02673296407973</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">34.91147650009415</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.4941631223400505</span> <span class="mi">1626537623000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0103</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">71.34822444566278</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.19576623496297</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.4046734235304059</span> <span class="mi">1626537623000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0200</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">73.57230556533555</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.77102288427073</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.5317633226995193</span> <span class="mi">1626537623000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0201</span> <span class="nx">temperature</span><span class="o">=</span><span class="nx">c</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.17327249047271</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.5000439017037601</span> <span class="mi">1626537623000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0202</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">75.28582430811852</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.668729783597556</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.48071553398947864</span> <span class="mi">1626537623000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0203</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">74.75927935923579</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.89268792033798</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.4089308476612381</span> <span class="mi">1626537623000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0100</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">71.2194835668512</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.12891266051405</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.4958773037139102</span> <span class="mi">1626537633000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0101</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">71.78232293801005</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">34.88621453634278</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.5074032895942003</span> <span class="mi">1626537633000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0102</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">72.07101160147653</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">34.938529830668536</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.5102716855442547</span> <span class="mi">1626537633000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0103</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">71.32889101333731</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.21581883021604</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.4245915521103036</span> <span class="mi">1626537633000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0200</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">73.55081075397399</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.74330537831752</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.5435288991742965</span> <span class="mi">1626537633000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0201</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">74.06284877512215</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.17611147751894</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.4813785832360323</span> <span class="mi">1626537633000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0202</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">75.29425020175684</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.64366062740866</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.4911462705616819</span> <span class="mi">1626537633000000000</span>
<span class="nx">airSensors</span><span class="p">,</span><span class="nx">sensor_id</span><span class="o">=</span><span class="nx">TLM0203</span> <span class="nx">temperature</span><span class="o">=</span><span class="mf">74.77142594525142</span><span class="p">,</span><span class="nx">humidity</span><span class="o">=</span><span class="mf">35.941017361190255</span><span class="p">,</span><span class="nx">co</span><span class="o">=</span><span class="mf">0.42797647488504065</span> <span class="mi">1626537633000000000</span>
</code></pre></div></div>

<p>Answer 3:</p>

<p>The line protocol would result in the following series and tables on disk. Each series contains two points from the line protocol above.</p>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0100
   </td>
   <td>temperature
   </td>
   <td>73.57230556533555
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0100
   </td>
   <td>temperature
   </td>
   <td>71.2194835668512
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0101
   </td>
   <td>temperature
   </td>
   <td>72.02673296407973
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0101
   </td>
   <td>temperature
   </td>
   <td>71.78232293801005
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0102
   </td>
   <td>temperature
   </td>
   <td>73.57230556533555
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0102
   </td>
   <td>temperature
   </td>
   <td>72.07101160147653
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0103
   </td>
   <td>temperature
   </td>
   <td>71.34822444566278
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0103
   </td>
   <td>temperature
   </td>
   <td>71.32889101333731
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0200
   </td>
   <td>temperature
   </td>
   <td>73.57230556533555
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0200
   </td>
   <td>temperature
   </td>
   <td>73.55081075397399
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0201
   </td>
   <td>temperature
   </td>
   <td>73.57230556521233
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0201
   </td>
   <td>temperature
   </td>
   <td>74.06284877512215
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0202
   </td>
   <td>temperature
   </td>
   <td>75.28582430811852
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0202
   </td>
   <td>temperature
   </td>
   <td>75.29425020175684
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0203
   </td>
   <td>temperature
   </td>
   <td>74.75927935923579
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0203
   </td>
   <td>temperature
   </td>
   <td>74.77142594525142
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0100
   </td>
   <td>humidity
   </td>
   <td>35.12940716174776
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0100
   </td>
   <td>humidity
   </td>
   <td>35.12891266051405
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0101
   </td>
   <td>humidity
   </td>
   <td>34.864121891949736
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0101
   </td>
   <td>humidity
   </td>
   <td>34.88621453634278
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0102
   </td>
   <td>humidity
   </td>
   <td>34.91147650009415
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0102
   </td>
   <td>humidity
   </td>
   <td>34.938529830668536
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0103
   </td>
   <td>humidity
   </td>
   <td>35.19576623496297
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0103
   </td>
   <td>humidity
   </td>
   <td>35.21581883021604
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0200
   </td>
   <td>humidity
   </td>
   <td>35.77102288427073
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0200
   </td>
   <td>humidity
   </td>
   <td>35.74330537831752
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0201
   </td>
   <td>humidity
   </td>
   <td>35.17327249047271
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0201
   </td>
   <td>humidity
   </td>
   <td>35.17611147751894
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0202
   </td>
   <td>humidity
   </td>
   <td>35.668729783597556
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0202
   </td>
   <td>humidity
   </td>
   <td>35.64366062740866
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0203
   </td>
   <td>humidity
   </td>
   <td>35.89268792033798
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0203
   </td>
   <td>humidity
   </td>
   <td>35.941017361190255
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0100
   </td>
   <td>co
   </td>
   <td>0.4925449578765155
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0100
   </td>
   <td>co
   </td>
   <td>0.495877303713910
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0101
   </td>
   <td>co
   </td>
   <td>0.4925449578765155
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0101
   </td>
   <td>co
   </td>
   <td>0.5074032895942003
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0102
   </td>
   <td>co
   </td>
   <td>0.4941631223400505
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0102
   </td>
   <td>co
   </td>
   <td>0.5102716855442547
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0103
   </td>
   <td>co
   </td>
   <td>0.4046734235304059
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0103
   </td>
   <td>co
   </td>
   <td>0.4245915521103036
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0200
   </td>
   <td>co
   </td>
   <td>0.5317633226995193
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0200
   </td>
   <td>co
   </td>
   <td>0.5435288991742965
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0201
   </td>
   <td>co
   </td>
   <td>0.5000439017037601
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0201
   </td>
   <td>co
   </td>
   <td>0.4813785832360323
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement
   </td>
   <td>sensor_id
   </td>
   <td>_field
   </td>
   <td>_value
   </td>
   <td>_time
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0202
   </td>
   <td>co
   </td>
   <td>0.48071553398947864
   </td>
   <td>rfc3339time1
   </td>
  </tr>
  <tr>
   <td>airSensors
   </td>
   <td>TLM0202
   </td>
   <td>co
   </td>
   <td>0.4911462705616819
   </td>
   <td>rfc3339time2
   </td>
  </tr>
</table>

<table>
  <tr>
   <td>_measurement

   </td>
   <td>sensor_id

   </td>
   <td>_field

   </td>
   <td>_value

   </td>
   <td>_time

   </td>
  </tr>
  <tr>
   <td>airSensors

   </td>
   <td>TLM0203

   </td>
   <td>co

   </td>
   <td>0.4089308476612381

   </td>
   <td>rfc3339time1

   </td>
  </tr>
  <tr>
   <td>airSensors

   </td>
   <td>TLM0203

   </td>
   <td>co

   </td>
   <td>0.42797647488504065

   </td>
   <td>rfc3339time2

   </td>
  </tr>
</table>

<p><a href="/time-to-awesome/docs/part-2/designing-your-schema" class="btn btn-purple">Next Section</a></p>
:ET